Index: Dockerfile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>FROM openjdk:8-jre-slim\n\n# Installa dipendenze base con retry\nRUN for i in 1 2 3; do \\\n    apt-get update && \\\n    apt-get install -y \\\n        wget \\\n        curl \\\n        unzip \\\n        ca-certificates \\\n        gnupg \\\n        fonts-liberation \\\n        libasound2 \\\n        libatk-bridge2.0-0 \\\n        libatk1.0-0 \\\n        libatspi2.0-0 \\\n        libcups2 \\\n        libdbus-1-3 \\\n        libdrm2 \\\n        libgtk-3-0 \\\n        libnspr4 \\\n        libnss3 \\\n        libwayland-client0 \\\n        libxcomposite1 \\\n        libxdamage1 \\\n        libxfixes3 \\\n        libxkbcommon0 \\\n        libxrandr2 \\\n        libxss1 \\\n        libgbm1 \\\n        xdg-utils \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && break || \\\n    (echo \"Attempt $i failed, retrying...\" && sleep 10); \\\ndone\n\n# Rileva architettura e installa browser appropriato con retry\nRUN ARCH=$(dpkg --print-architecture) && \\\n    echo \"Detected architecture: $ARCH\" && \\\n    for i in 1 2 3; do \\\n        if [ \"$ARCH\" = \"amd64\" ]; then \\\n            echo \"Installing Chrome for AMD64...\" && \\\n            wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add - && \\\n            echo \"deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\" > /etc/apt/sources.list.d/google-chrome.list && \\\n            apt-get update && \\\n            apt-get install -y google-chrome-stable && \\\n            ln -sf /usr/bin/google-chrome-stable /usr/bin/chrome && \\\n            break; \\\n        else \\\n            echo \"Installing Chromium for ARM64...\" && \\\n            apt-get update && \\\n            apt-get install -y chromium chromium-driver && \\\n            ln -sf /usr/bin/chromium /usr/bin/chrome && \\\n            break; \\\n        fi || \\\n        (echo \"Browser install attempt $i failed, retrying...\" && sleep 10); \\\n    done && \\\n    rm -rf /var/lib/apt/lists/*\n\n# Crea utente non-root\nRUN useradd -ms /bin/bash appuser && \\\n    mkdir -p /app /app/temp /app/logs && \\\n    chown -R appuser:appuser /app\n\nWORKDIR /app\n\n# Copia il JAR\nCOPY target/file-type-converter-*.jar app.jar\nRUN chown appuser:appuser app.jar\n\n# Script di avvio ottimizzato\nRUN echo '#!/bin/bash\\n\\\nset -e\\n\\\n\\n\\\necho \"=== AVVIO CONTAINER ===\"\\n\\\n\\n\\\n# Rileva browser disponibile\\n\\\nif [ -f \"/usr/bin/google-chrome-stable\" ]; then\\n\\\n    export CHROME_PATH=\"/usr/bin/google-chrome-stable\"\\n\\\n    echo \"Using Google Chrome Stable\"\\n\\\nelif [ -f \"/usr/bin/google-chrome\" ]; then\\n\\\n    export CHROME_PATH=\"/usr/bin/google-chrome\"\\n\\\n    echo \"Using Google Chrome\"\\n\\\nelif [ -f \"/usr/bin/chromium\" ]; then\\n\\\n    export CHROME_PATH=\"/usr/bin/chromium\"\\n\\\n    echo \"Using Chromium\"\\n\\\nelse\\n\\\n    echo \"ERROR: No browser found!\"\\n\\\n    echo \"Available binaries:\"\\n\\\n    ls -la /usr/bin/ | grep -E \"(chrome|chromium)\" || echo \"None found\"\\n\\\n    exit 1\\n\\\nfi\\n\\\n\\n\\\n# Test browser\\n\\\necho \"Testing browser...\"\\n\\\n$CHROME_PATH --version || { echo \"Browser test failed\"; exit 1; }\\n\\\n\\n\\\n# Imposta argomenti Chrome ottimizzati\\n\\\nexport CHROME_ARGS=\"--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-background-timer-throttling --disable-renderer-backgrounding --disable-features=TranslateUI --remote-debugging-port=0\"\\n\\\n\\n\\\necho \"Starting application with browser: $CHROME_PATH\"\\n\\\necho \"Java opts: $JAVA_OPTS\"\\n\\\nexec java $JAVA_OPTS -Dserver.address=0.0.0.0 -jar app.jar' > start.sh && \\\nchmod +x start.sh && \\\nchown appuser:appuser start.sh\n\n# Cambia a utente non-root\nUSER appuser\n\nEXPOSE 8080\n\n# Environment variables\nENV JAVA_OPTS=\"-Xmx5g -Xms4096m\"\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\\n    CMD curl -f http://localhost:8080/api/converter/status || exit 1\n\n# Avvio\nCMD [\"./start.sh\"]
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Dockerfile b/Dockerfile
--- a/Dockerfile	(revision c03fcda81ec80ee23b4f0e9aa9b8f8e2a00cc447)
+++ b/Dockerfile	(date 1751440216700)
@@ -1,9 +1,13 @@
-FROM openjdk:8-jre-slim
+FROM ubuntu:20.04
 
-# Installa dipendenze base con retry
+# Evita prompt interattivi
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Installa Java 8 + dipendenze base con retry
 RUN for i in 1 2 3; do \
     apt-get update && \
     apt-get install -y \
+        openjdk-8-jre-headless \
         wget \
         curl \
         unzip \
@@ -28,34 +32,40 @@
         libxrandr2 \
         libxss1 \
         libgbm1 \
+        libx11-xcb1 \
+        libxcursor1 \
+        libxi6 \
+        libxtst6 \
         xdg-utils \
     && rm -rf /var/lib/apt/lists/* \
     && break || \
     (echo "Attempt $i failed, retrying..." && sleep 10); \
 done
 
-# Rileva architettura e installa browser appropriato con retry
-RUN ARCH=$(dpkg --print-architecture) && \
-    echo "Detected architecture: $ARCH" && \
-    for i in 1 2 3; do \
-        if [ "$ARCH" = "amd64" ]; then \
-            echo "Installing Chrome for AMD64..." && \
-            wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add - && \
-            echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list && \
-            apt-get update && \
-            apt-get install -y google-chrome-stable && \
-            ln -sf /usr/bin/google-chrome-stable /usr/bin/chrome && \
-            break; \
-        else \
-            echo "Installing Chromium for ARM64..." && \
-            apt-get update && \
-            apt-get install -y chromium chromium-driver && \
-            ln -sf /usr/bin/chromium /usr/bin/chrome && \
-            break; \
-        fi || \
-        (echo "Browser install attempt $i failed, retrying..." && sleep 10); \
-    done && \
-    rm -rf /var/lib/apt/lists/*
+# Installa Chrome for Testing (per automazione headless)
+RUN echo "=== INSTALLING CHROME FOR TESTING ===" && \
+    CHROME_VERSION=$(curl -s https://googlechromelabs.github.io/chrome-for-testing/last-known-good-versions.json | grep -o '"version":"[^"]*"' | head -1 | cut -d'"' -f4) && \
+    echo "Chrome version: $CHROME_VERSION" && \
+    wget -q "https://storage.googleapis.com/chrome-for-testing-public/${CHROME_VERSION}/linux64/chrome-linux64.zip" && \
+    unzip -q chrome-linux64.zip && \
+    mv chrome-linux64 /opt/chrome && \
+    ln -sf /opt/chrome/chrome /usr/bin/google-chrome-stable && \
+    ln -sf /opt/chrome/chrome /usr/bin/google-chrome && \
+    ln -sf /opt/chrome/chrome /usr/bin/chrome && \
+    rm -f chrome-linux64.zip && \
+    echo "Chrome for Testing installed successfully"
+
+# Verifica installazione browser
+RUN echo "=== FINAL BROWSER TEST ===" && \
+    ls -la /usr/bin/chrome && \
+    /usr/bin/chrome --version || { \
+        echo "Chrome test failed, trying alternatives..." && \
+        /usr/bin/google-chrome-stable --version 2>/dev/null || \
+        /usr/bin/google-chrome --version 2>/dev/null || \
+        /opt/google/chrome/chrome --version 2>/dev/null || \
+        /usr/bin/chromium-browser --version 2>/dev/null || \
+        { echo "All browser tests failed"; exit 1; }; \
+    }
 
 # Crea utente non-root
 RUN useradd -ms /bin/bash appuser && \
@@ -68,7 +78,7 @@
 COPY target/file-type-converter-*.jar app.jar
 RUN chown appuser:appuser app.jar
 
-# Script di avvio ottimizzato
+# Script di avvio ottimizzato (SENZA --remote-debugging-port=0)
 RUN echo '#!/bin/bash\n\
 set -e\n\
 \n\
@@ -95,8 +105,19 @@
 echo "Testing browser..."\n\
 $CHROME_PATH --version || { echo "Browser test failed"; exit 1; }\n\
 \n\
-# Imposta argomenti Chrome ottimizzati\n\
-export CHROME_ARGS="--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-background-timer-throttling --disable-renderer-backgrounding --disable-features=TranslateUI --remote-debugging-port=0"\n\
+# Test PDF generation\n\
+echo "Testing PDF generation..."\n\
+echo "<html><body><h1>Test</h1></body></html>" > /tmp/test.html\n\
+$CHROME_PATH --headless --disable-gpu --no-sandbox --disable-dev-shm-usage --print-to-pdf=/tmp/test.pdf file:///tmp/test.html || echo "PDF test failed"\n\
+if [ -f "/tmp/test.pdf" ]; then\n\
+    echo "✅ PDF generation test: SUCCESS"\n\
+    rm -f /tmp/test.pdf /tmp/test.html\n\
+else\n\
+    echo "❌ PDF generation test: FAILED"\n\
+fi\n\
+\n\
+# Imposta argomenti Chrome ottimizzati (SENZA remote-debugging)\n\
+export CHROME_ARGS="--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-background-timer-throttling --disable-renderer-backgrounding --disable-features=TranslateUI"\n\
 \n\
 echo "Starting application with browser: $CHROME_PATH"\n\
 echo "Java opts: $JAVA_OPTS"\n\
Index: src/main/resources/converter.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># converter.properties - Google Chrome Stable\n\n# Chrome paths per Google Chrome\nchrome.docker.paths=/usr/bin/google-chrome:/usr/bin/google-chrome-stable:/usr/bin/chromium-browser\nchrome.linux.path=/usr/bin/google-chrome\n\n# Args per Google Chrome Headless\nchrome.args=--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-background-timer-throttling --remote-debugging-port=0\n\n# Settings\nchrome.timeout.seconds=30\nchrome.temp.cleanup=true
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/src/main/resources/converter.properties b/src/main/resources/converter.properties
--- a/src/main/resources/converter.properties	(revision c03fcda81ec80ee23b4f0e9aa9b8f8e2a00cc447)
+++ b/src/main/resources/converter.properties	(date 1751445662145)
@@ -1,12 +1,18 @@
-# converter.properties - Google Chrome Stable
+# converter.properties - Configurazione Chrome per Docker Container
+
+# Chrome paths per il container Docker
+chrome.docker.paths=/usr/bin/chrome:/opt/chrome/chrome:/usr/bin/google-chrome:/usr/bin/google-chrome-stable:/usr/bin/chromium-browser
 
-# Chrome paths per Google Chrome
-chrome.docker.paths=/usr/bin/google-chrome:/usr/bin/google-chrome-stable:/usr/bin/chromium-browser
-chrome.linux.path=/usr/bin/google-chrome
+# Argomenti Chrome ottimizzati per container Docker
+chrome.args=--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-web-security --allow-file-access-from-files --disable-features=VizDisplayCompositor --disable-background-timer-throttling --disable-backgrounding-occluded-windows --disable-renderer-backgrounding --disable-features=TranslateUI --run-all-compositor-stages-before-draw --disable-ipc-flooding-protection --virtual-time-budget=30000
 
-# Args per Google Chrome Headless
-chrome.args=--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-background-timer-throttling --remote-debugging-port=0
+# Timeout per operazioni Chrome
+chrome.timeout.seconds=60
 
-# Settings
-chrome.timeout.seconds=30
-chrome.temp.cleanup=true
\ No newline at end of file
+# Cleanup automatico file temporanei
+chrome.temp.cleanup=true
+
+# Percorsi di fallback per diversi OS (non usati in Docker ma mantenuti per compatibilità)
+chrome.fallback.linux=/usr/bin/google-chrome:/usr/bin/chromium-browser
+chrome.fallback.windows=C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe
+chrome.fallback.mac=/Applications/Google Chrome.app/Contents/MacOS/Google Chrome
\ No newline at end of file
Index: docker-compose.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>services:\n  # Servizio PostgreSQL\n  postgres:\n    image: postgres:14-alpine\n    container_name: file-converter-postgres\n    environment:\n      - POSTGRES_DB=bytebridge\n      - POSTGRES_USER=admin\n      - POSTGRES_PASSWORD=bytebridge\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U admin -d bytebridge\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    networks:\n      - converter-network\n    restart: unless-stopped\n\n  # Servizio applicazione\n  converter-service:\n    image: file-converter-auth:latest\n    container_name: file-converter-app\n    ports:\n      - \"0.0.0.0:8080:8080\"\n    environment:\n      - JAVA_OPTS=-Xmx5g -Xms4096m\n      - SERVER_ADDRESS=0.0.0.0\n      - SERVER_PORT=8080\n      - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/bytebridge\n      - SPRING_DATASOURCE_USERNAME=admin\n      - SPRING_DATASOURCE_PASSWORD=bytebridge\n      - CHROME_PATH=/usr/bin/chrome\n      - CHROME_ARGS=--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-background-timer-throttling --disable-renderer-backgrounding --disable-features=TranslateUI --remote-debugging-port=0\n    volumes:\n      - ./logs:/app/logs\n      - ./temp:/app/temp\n      - /usr/share/fonts:/usr/share/fonts:ro\n    shm_size: 2gb\n    security_opt:\n      - seccomp:unconfined\n    restart: unless-stopped\n    depends_on:\n      postgres:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/api/converter/status\"]\n      interval: 100s\n      timeout: 10s\n      retries: 3\n      start_period: 60s\n    networks:\n      - converter-network\n\nvolumes:\n  postgres_data:\n    driver: local\n\nnetworks:\n  converter-network:\n    driver: bridge
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docker-compose.yml b/docker-compose.yml
--- a/docker-compose.yml	(revision c03fcda81ec80ee23b4f0e9aa9b8f8e2a00cc447)
+++ b/docker-compose.yml	(date 1751438932765)
@@ -23,42 +23,55 @@
   # Servizio applicazione
   converter-service:
     image: file-converter-auth:latest
-    container_name: file-converter-app
+    container_name: file-converter-server
     ports:
       - "0.0.0.0:8080:8080"
     environment:
       - JAVA_OPTS=-Xmx5g -Xms4096m
-      - SERVER_ADDRESS=0.0.0.0
+      - SERVER_ADDRESS=0.0.0.0  # Ascolta su tutte le interfacce
       - SERVER_PORT=8080
+      
+      # Database PostgreSQL connection
       - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/bytebridge
       - SPRING_DATASOURCE_USERNAME=admin
       - SPRING_DATASOURCE_PASSWORD=bytebridge
+      
+      # Chrome environment variables
       - CHROME_PATH=/usr/bin/chrome
       - CHROME_ARGS=--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-background-timer-throttling --disable-renderer-backgrounding --disable-features=TranslateUI --remote-debugging-port=0
+
     volumes:
       - ./logs:/app/logs
       - ./temp:/app/temp
       - /usr/share/fonts:/usr/share/fonts:ro
+
+    # Configurazioni per Chrome
     shm_size: 2gb
     security_opt:
       - seccomp:unconfined
+    
     restart: unless-stopped
+    
+    # Aspetta che PostgreSQL sia pronto
     depends_on:
       postgres:
         condition: service_healthy
+    
     healthcheck:
       test: ["CMD", "curl", "-f", "http://localhost:8080/api/converter/status"]
-      interval: 100s
+      interval: 30s
       timeout: 10s
       retries: 3
       start_period: 60s
+
     networks:
       - converter-network
 
+# Volumi persistenti
 volumes:
   postgres_data:
     driver: local
 
 networks:
   converter-network:
-    driver: bridge
\ No newline at end of file
+    driver: bridge
Index: src/main/java/webService/server/converters/mailConverters/ChromeManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package webService.server.converters.mailConverters;\n\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\n/**\n * Gestisce la localizzazione e configurazione di Chrome Headless per Docker.\n * Ottimizzato per container Linux con Chrome preinstallato.\n * Implementa il pattern Singleton e cerca automaticamente l'eseguibile Chrome.\n */\npublic class ChromeManager {\n\n    private static final Logger logger = LogManager.getLogger(ChromeManager.class);\n    private static ChromeManager instance;\n    private static String chromePath;\n    private static boolean initialized = false;\n\n    /**\n     * Costruttore privato per implementare il pattern Singleton.\n     */\n    private ChromeManager() {}\n\n    /**\n     * Restituisce l'istanza singleton di ChromeManager, inizializzandola se necessario.\n     *\n     * @return L'istanza singleton di ChromeManager\n     */\n    public static synchronized ChromeManager getInstance() {\n        if (instance == null) {\n            instance = new ChromeManager();\n            initialize();\n        }\n        return instance;\n    }\n\n    /**\n     * Inizializza il ChromeManager caricando la configurazione e cercando l'eseguibile Chrome.\n     * Ottimizzato per ambiente Docker.\n     */\n    private static void initialize() {\n        if (initialized) return;\n\n        try {\n            // Carica configurazione dalle risorse\n            Properties config = loadConfig();\n\n            // Trova Chrome (priorità a Docker paths)\n            chromePath = findChromeExecutable(config);\n\n            if (chromePath != null) {\n                logger.info(\"Chrome configurato per Docker: {}\", chromePath);\n\n                // Test veloce per verificare che Chrome funzioni\n                if (testChrome(chromePath)) {\n                    logger.info(\"Chrome validato con successo\");\n                } else {\n                    logger.warn(\"Chrome trovato ma non risponde correttamente\");\n                    chromePath = null;\n                }\n            } else {\n                logger.warn(\"Chrome non trovato - Conversioni PDF non disponibili\");\n            }\n\n            initialized = true;\n\n        } catch (Exception e) {\n            logger.error(\"Errore nell'inizializzazione Chrome\", e);\n            chromePath = null;\n            initialized = true; // Evita retry infiniti\n        }\n    }\n\n    /**\n     * Carica le proprietà di configurazione da converter.properties nelle risorse.\n     *\n     * @return Oggetto Properties contenente la configurazione caricata\n     * @throws IOException Se si verificano errori durante il caricamento del file\n     */\n    private static Properties loadConfig() throws IOException {\n        Properties config = new Properties();\n\n        // Carica sempre dalle risorse (post-build)\n        try (InputStream is = ChromeManager.class.getClassLoader().getResourceAsStream(\"converter.properties\")) {\n            if (is != null) {\n                config.load(is);\n                logger.debug(\"Configurazione Chrome caricata dalle risorse\");\n            } else {\n                logger.warn(\"converter.properties non trovato nelle risorse, uso configurazione default\");\n                // Imposta valori di default per Docker\n                setDefaultDockerConfig(config);\n            }\n        }\n\n        return config;\n    }\n\n    /**\n     * Imposta la configurazione di default ottimizzata per Docker.\n     *\n     * @param config Oggetto Properties da popolare\n     */\n    private static void setDefaultDockerConfig(Properties config) {\n        // Percorsi standard per Docker Linux\n        config.setProperty(\"chrome.docker.paths\",\n                \"/usr/bin/google-chrome:/usr/bin/google-chrome-stable:/usr/bin/chromium-browser:/usr/bin/chromium\");\n\n        // Argomenti ottimizzati per Docker\n        config.setProperty(\"chrome.args\",\n                \"--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-background-timer-throttling --disable-renderer-backgrounding --disable-features=TranslateUI --remote-debugging-port=0\");\n\n        config.setProperty(\"chrome.timeout.seconds\", \"30\");\n        config.setProperty(\"chrome.temp.cleanup\", \"true\");\n    }\n\n    /**\n     * Cerca l'eseguibile Chrome utilizzando strategie ottimizzate per Docker.\n     * Priorità: variabile d'ambiente → paths Docker → PATH di sistema\n     *\n     * @param config Configurazione caricata\n     * @return Il percorso assoluto dell'eseguibile Chrome, o null se non trovato\n     */\n    private static String findChromeExecutable(Properties config) {\n        // 1. Variabile d'ambiente CHROME_PATH (massima priorità)\n        String envPath = System.getenv(\"CHROME_PATH\");\n        if (isValidExecutable(envPath)) {\n            logger.info(\"Chrome trovato da variabile d'ambiente: {}\", envPath);\n            return envPath;\n        }\n\n        // 2. Symlink generico /usr/bin/chrome (creato dal Dockerfile)\n        String genericPath = \"/usr/bin/chrome\";\n        if (isValidExecutable(genericPath)) {\n            logger.info(\"Chrome trovato tramite symlink generico: {}\", genericPath);\n            return genericPath;\n        }\n\n        // 3. Percorsi Docker standard dalla configurazione\n        String dockerPaths = config.getProperty(\"chrome.docker.paths\",\n                \"/usr/bin/google-chrome-stable:/usr/bin/google-chrome:/usr/bin/chromium-browser:/usr/bin/chromium\");\n\n        for (String path : dockerPaths.split(\":\")) {\n            if (isValidExecutable(path.trim())) {\n                logger.info(\"Chrome trovato nei percorsi Docker: {}\", path.trim());\n                return path.trim();\n            }\n        }\n\n        // 4. Fallback: cerca nel PATH di sistema\n        String pathChrome = findInPath();\n        if (pathChrome != null) {\n            logger.info(\"Chrome trovato nel PATH: {}\", pathChrome);\n            return pathChrome;\n        }\n\n        // 5. DEBUG: Lista tutti i possibili eseguibili\n        logger.error(\"Chrome non trovato. Eseguibili disponibili:\");\n        try {\n            Process process = Runtime.getRuntime().exec(new String[]{\"ls\", \"-la\", \"/usr/bin/\"});\n            try (java.io.BufferedReader reader = new java.io.BufferedReader(\n                    new java.io.InputStreamReader(process.getInputStream()))) {\n                reader.lines()\n                        .filter(line -> line.contains(\"chrome\") || line.contains(\"chromium\"))\n                        .forEach(line -> logger.error(\"  {}\", line));\n            }\n        } catch (Exception e) {\n            logger.error(\"Impossibile listare /usr/bin/\");\n        }\n\n        logger.error(\"Chrome non trovato in nessun percorso standard\");\n        return null;\n    }\n\n    /**\n     * Cerca Chrome nel PATH di sistema usando which command.\n     * Ottimizzato per ambiente Linux Docker.\n     *\n     * @return Il percorso di Chrome trovato nel PATH, o null se non trovato\n     */\n    private static String findInPath() {\n        String[] commands = {\n                \"google-chrome\",\n                \"google-chrome-stable\",\n                \"chromium-browser\",\n                \"chromium\"\n        };\n\n        for (String command : commands) {\n            try {\n                Process process = Runtime.getRuntime().exec(new String[]{\"which\", command});\n                process.waitFor();\n\n                if (process.exitValue() == 0) {\n                    try (java.io.BufferedReader reader = new java.io.BufferedReader(\n                            new java.io.InputStreamReader(process.getInputStream()))) {\n                        String path = reader.readLine();\n                        if (path != null && !path.trim().isEmpty()) {\n                            return path.trim();\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"Errore ricerca {} nel PATH: {}\", command, e.getMessage());\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test rapido per verificare che Chrome sia funzionante.\n     *\n     * @param chromePath Percorso di Chrome da testare\n     * @return true se Chrome risponde correttamente, false altrimenti\n     */\n    private static boolean testChrome(String chromePath) {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(chromePath, \"--version\");\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n\n            int exitCode = process.waitFor();\n            return exitCode == 0;\n        } catch (Exception e) {\n            logger.debug(\"Test Chrome fallito: {}\", e.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Verifica se un percorso rappresenta un eseguibile valido e accessibile.\n     *\n     * @param path Il percorso da verificare\n     * @return true se il percorso è un file eseguibile valido, false altrimenti\n     */\n    private static boolean isValidExecutable(String path) {\n        if (path == null || path.trim().isEmpty()) {\n            return false;\n        }\n\n        File file = new File(path);\n        return file.exists() && file.canExecute();\n    }\n\n    /**\n     * Verifica se Chrome è disponibile e configurato correttamente.\n     *\n     * @return true se Chrome è disponibile per l'uso, false altrimenti\n     */\n    public boolean isChromeAvailable() {\n        return chromePath != null;\n    }\n\n    /**\n     * Restituisce il percorso dell'eseguibile Chrome configurato.\n     *\n     * @return Il percorso assoluto di Chrome, o null se non disponibile\n     */\n    public String getChromePath() {\n        return chromePath;\n    }\n\n    /**\n     * Restituisce gli argomenti di Chrome ottimizzati per Docker.\n     *\n     * @return Array di argomenti per Chrome\n     */\n    public String[] getChromeArgs() {\n        try {\n            Properties config = loadConfig();\n            String args = config.getProperty(\"chrome.args\",\n                    \"--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --remote-debugging-port=0\");\n            return args.split(\"\\\\s+\");\n        } catch (Exception e) {\n            logger.warn(\"Errore caricamento argomenti Chrome, uso default: {}\", e.getMessage());\n            return new String[]{\"--headless\", \"--disable-gpu\", \"--no-sandbox\", \"--disable-dev-shm-usage\"};\n        }\n    }\n\n    /**\n     * Valida che Chrome sia disponibile e funzionante eseguendo un test completo.\n     *\n     * @throws IOException Se Chrome non è disponibile o non risponde correttamente\n     */\n    public void validateChrome() throws IOException {\n        if (!isChromeAvailable()) {\n            throw new IOException(\"Chrome non disponibile per conversione PDF - Verifica installazione Docker\");\n        }\n\n        // Test più approfondito con timeout\n        try {\n            ProcessBuilder pb = new ProcessBuilder(chromePath, \"--version\");\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n\n            boolean finished = process.waitFor(10, java.util.concurrent.TimeUnit.SECONDS);\n\n            if (!finished) {\n                process.destroyForcibly();\n                throw new IOException(\"Chrome non risponde entro il timeout\");\n            }\n\n            if (process.exitValue() != 0) {\n                throw new IOException(\"Chrome restituisce codice di errore: \" + process.exitValue());\n            }\n\n            logger.info(\"Chrome validato con successo: {}\", chromePath);\n\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new IOException(\"Test Chrome interrotto\", e);\n        }\n    }\n\n    /**\n     * Crea un ProcessBuilder configurato per Chrome con argomenti ottimizzati per Docker.\n     *\n     * @param additionalArgs Argomenti aggiuntivi specifici per l'operazione\n     * @return ProcessBuilder configurato\n     * @throws IOException Se Chrome non è disponibile\n     */\n    public ProcessBuilder createChromeProcess(String... additionalArgs) throws IOException {\n        if (!isChromeAvailable()) {\n            throw new IOException(\"Chrome non disponibile\");\n        }\n\n        String[] baseArgs = getChromeArgs();\n        String[] allArgs = new String[1 + baseArgs.length + additionalArgs.length];\n\n        allArgs[0] = chromePath;\n        System.arraycopy(baseArgs, 0, allArgs, 1, baseArgs.length);\n        System.arraycopy(additionalArgs, 0, allArgs, 1 + baseArgs.length, additionalArgs.length);\n\n        ProcessBuilder pb = new ProcessBuilder(allArgs);\n        pb.redirectErrorStream(true);\n\n        return pb;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/webService/server/converters/mailConverters/ChromeManager.java b/src/main/java/webService/server/converters/mailConverters/ChromeManager.java
--- a/src/main/java/webService/server/converters/mailConverters/ChromeManager.java	(revision c03fcda81ec80ee23b4f0e9aa9b8f8e2a00cc447)
+++ b/src/main/java/webService/server/converters/mailConverters/ChromeManager.java	(date 1751445733320)
@@ -9,9 +9,8 @@
 import java.util.Properties;
 
 /**
- * Gestisce la localizzazione e configurazione di Chrome Headless per Docker.
- * Ottimizzato per container Linux con Chrome preinstallato.
- * Implementa il pattern Singleton e cerca automaticamente l'eseguibile Chrome.
+ * Gestisce la localizzazione e configurazione di Chrome Headless per Docker container.
+ * Ottimizzato specificamente per il setup Docker con Chrome for Testing.
  */
 public class ChromeManager {
 
@@ -20,16 +19,8 @@
     private static String chromePath;
     private static boolean initialized = false;
 
-    /**
-     * Costruttore privato per implementare il pattern Singleton.
-     */
     private ChromeManager() {}
 
-    /**
-     * Restituisce l'istanza singleton di ChromeManager, inizializzandola se necessario.
-     *
-     * @return L'istanza singleton di ChromeManager
-     */
     public static synchronized ChromeManager getInstance() {
         if (instance == null) {
             instance = new ChromeManager();
@@ -38,60 +29,52 @@
         return instance;
     }
 
-    /**
-     * Inizializza il ChromeManager caricando la configurazione e cercando l'eseguibile Chrome.
-     * Ottimizzato per ambiente Docker.
-     */
     private static void initialize() {
         if (initialized) return;
 
         try {
-            // Carica configurazione dalle risorse
+            // Carica configurazione from resources
             Properties config = loadConfig();
 
-            // Trova Chrome (priorità a Docker paths)
+            // Trova Chrome nel container
             chromePath = findChromeExecutable(config);
 
             if (chromePath != null) {
-                logger.info("Chrome configurato per Docker: {}", chromePath);
+                logger.info("Chrome configurato per Docker container: {}", chromePath);
 
-                // Test veloce per verificare che Chrome funzioni
-                if (testChrome(chromePath)) {
-                    logger.info("Chrome validato con successo");
+                // Test Chrome version
+                testAndLogChromeVersion(chromePath);
+
+                // Test PDF generation
+                if (testPdfGeneration(chromePath)) {
+                    logger.info("Chrome PDF generation test: SUCCESS");
                 } else {
-                    logger.warn("Chrome trovato ma non risponde correttamente");
-                    chromePath = null;
+                    logger.warn("Chrome PDF generation test: FAILED");
                 }
             } else {
-                logger.warn("Chrome non trovato - Conversioni PDF non disponibili");
+                logger.error("Chrome NON TROVATO nel container - Conversioni PDF non disponibili");
+                logAvailableBrowsers();
             }
 
             initialized = true;
 
         } catch (Exception e) {
-            logger.error("Errore nell'inizializzazione Chrome", e);
+            logger.error("Errore nell'inizializzazione Chrome in Docker container", e);
             chromePath = null;
-            initialized = true; // Evita retry infiniti
+            initialized = true;
         }
     }
 
-    /**
-     * Carica le proprietà di configurazione da converter.properties nelle risorse.
-     *
-     * @return Oggetto Properties contenente la configurazione caricata
-     * @throws IOException Se si verificano errori durante il caricamento del file
-     */
     private static Properties loadConfig() throws IOException {
         Properties config = new Properties();
 
-        // Carica sempre dalle risorse (post-build)
+        // Carica da resources/converter.properties
         try (InputStream is = ChromeManager.class.getClassLoader().getResourceAsStream("converter.properties")) {
             if (is != null) {
                 config.load(is);
-                logger.debug("Configurazione Chrome caricata dalle risorse");
+                logger.info("Configurazione Chrome caricata da resources/converter.properties");
             } else {
-                logger.warn("converter.properties non trovato nelle risorse, uso configurazione default");
-                // Imposta valori di default per Docker
+                logger.warn("converter.properties non trovato in resources, uso configurazione Docker default");
                 setDefaultDockerConfig(config);
             }
         }
@@ -99,95 +82,58 @@
         return config;
     }
 
-    /**
-     * Imposta la configurazione di default ottimizzata per Docker.
-     *
-     * @param config Oggetto Properties da popolare
-     */
     private static void setDefaultDockerConfig(Properties config) {
-        // Percorsi standard per Docker Linux
+        // Percorsi specifici per il tuo Docker setup
         config.setProperty("chrome.docker.paths",
-                "/usr/bin/google-chrome:/usr/bin/google-chrome-stable:/usr/bin/chromium-browser:/usr/bin/chromium");
+                "/usr/bin/chrome:/opt/chrome/chrome:/usr/bin/google-chrome:/usr/bin/google-chrome-stable:/usr/bin/chromium-browser");
 
-        // Argomenti ottimizzati per Docker
+        // Argomenti ottimizzati per container (senza remote-debugging come nel Dockerfile)
         config.setProperty("chrome.args",
-                "--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-background-timer-throttling --disable-renderer-backgrounding --disable-features=TranslateUI --remote-debugging-port=0");
+                "--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-web-security --allow-file-access-from-files --disable-features=VizDisplayCompositor --disable-background-timer-throttling --disable-backgrounding-occluded-windows --disable-renderer-backgrounding --disable-features=TranslateUI --run-all-compositor-stages-before-draw --disable-ipc-flooding-protection --virtual-time-budget=30000");
 
         config.setProperty("chrome.timeout.seconds", "30");
         config.setProperty("chrome.temp.cleanup", "true");
+
+        logger.info("Configurazione Docker default applicata");
     }
 
-    /**
-     * Cerca l'eseguibile Chrome utilizzando strategie ottimizzate per Docker.
-     * Priorità: variabile d'ambiente → paths Docker → PATH di sistema
-     *
-     * @param config Configurazione caricata
-     * @return Il percorso assoluto dell'eseguibile Chrome, o null se non trovato
-     */
     private static String findChromeExecutable(Properties config) {
-        // 1. Variabile d'ambiente CHROME_PATH (massima priorità)
+        logger.info("🔍 Ricerca Chrome nel container...");
+
+        // 1. Variabile d'ambiente CHROME_PATH (dal docker-compose)
         String envPath = System.getenv("CHROME_PATH");
         if (isValidExecutable(envPath)) {
-            logger.info("Chrome trovato da variabile d'ambiente: {}", envPath);
+            logger.info("Chrome trovato da CHROME_PATH: {}", envPath);
             return envPath;
         }
 
-        // 2. Symlink generico /usr/bin/chrome (creato dal Dockerfile)
-        String genericPath = "/usr/bin/chrome";
-        if (isValidExecutable(genericPath)) {
-            logger.info("Chrome trovato tramite symlink generico: {}", genericPath);
-            return genericPath;
-        }
-
-        // 3. Percorsi Docker standard dalla configurazione
+        // 2. Percorsi specifici del tuo Docker setup
         String dockerPaths = config.getProperty("chrome.docker.paths",
-                "/usr/bin/google-chrome-stable:/usr/bin/google-chrome:/usr/bin/chromium-browser:/usr/bin/chromium");
+                "/usr/bin/chrome:/opt/chrome/chrome:/usr/bin/google-chrome:/usr/bin/google-chrome-stable");
 
         for (String path : dockerPaths.split(":")) {
-            if (isValidExecutable(path.trim())) {
-                logger.info("Chrome trovato nei percorsi Docker: {}", path.trim());
-                return path.trim();
+            String trimmedPath = path.trim();
+            if (isValidExecutable(trimmedPath)) {
+                logger.info("Chrome trovato: {}", trimmedPath);
+                return trimmedPath;
+            } else {
+                logger.debug("Path non valido: {}", trimmedPath);
             }
         }
 
-        // 4. Fallback: cerca nel PATH di sistema
+        // 3. Fallback: which command
         String pathChrome = findInPath();
         if (pathChrome != null) {
             logger.info("Chrome trovato nel PATH: {}", pathChrome);
             return pathChrome;
         }
 
-        // 5. DEBUG: Lista tutti i possibili eseguibili
-        logger.error("Chrome non trovato. Eseguibili disponibili:");
-        try {
-            Process process = Runtime.getRuntime().exec(new String[]{"ls", "-la", "/usr/bin/"});
-            try (java.io.BufferedReader reader = new java.io.BufferedReader(
-                    new java.io.InputStreamReader(process.getInputStream()))) {
-                reader.lines()
-                        .filter(line -> line.contains("chrome") || line.contains("chromium"))
-                        .forEach(line -> logger.error("  {}", line));
-            }
-        } catch (Exception e) {
-            logger.error("Impossibile listare /usr/bin/");
-        }
-
-        logger.error("Chrome non trovato in nessun percorso standard");
+        logger.error("Chrome non trovato in nessun percorso");
         return null;
     }
 
-    /**
-     * Cerca Chrome nel PATH di sistema usando which command.
-     * Ottimizzato per ambiente Linux Docker.
-     *
-     * @return Il percorso di Chrome trovato nel PATH, o null se non trovato
-     */
     private static String findInPath() {
-        String[] commands = {
-                "google-chrome",
-                "google-chrome-stable",
-                "chromium-browser",
-                "chromium"
-        };
+        String[] commands = {"chrome", "google-chrome", "google-chrome-stable", "chromium-browser"};
 
         for (String command : commands) {
             try {
@@ -204,111 +150,171 @@
                     }
                 }
             } catch (Exception e) {
-                logger.debug("Errore ricerca {} nel PATH: {}", command, e.getMessage());
+                logger.debug("Comando 'which {}' fallito: {}", command, e.getMessage());
             }
         }
-
         return null;
     }
 
-    /**
-     * Test rapido per verificare che Chrome sia funzionante.
-     *
-     * @param chromePath Percorso di Chrome da testare
-     * @return true se Chrome risponde correttamente, false altrimenti
-     */
-    private static boolean testChrome(String chromePath) {
+    private static void testAndLogChromeVersion(String chromePath) {
         try {
             ProcessBuilder pb = new ProcessBuilder(chromePath, "--version");
-            pb.redirectErrorStream(true);
+            Process process = pb.start();
+
+            try (java.io.BufferedReader reader = new java.io.BufferedReader(
+                    new java.io.InputStreamReader(process.getInputStream()))) {
+                String version = reader.readLine();
+                process.waitFor();
+
+                if (process.exitValue() == 0 && version != null) {
+                    logger.info("🌟 Chrome version: {}", version);
+                } else {
+                    logger.warn("Chrome version test failed");
+                }
+            }
+        } catch (Exception e) {
+            logger.warn("Impossibile verificare versione Chrome: {}", e.getMessage());
+        }
+    }
+
+    private static boolean testPdfGeneration(String chromePath) {
+        try {
+            // Crea HTML test temporaneo
+            File tempHtml = File.createTempFile("chrome-test", ".html");
+            File tempPdf = File.createTempFile("chrome-test", ".pdf");
+
+            try (java.io.FileWriter writer = new java.io.FileWriter(tempHtml)) {
+                writer.write("<!DOCTYPE html><html><body><h1>Chrome PDF Test</h1><p>Se vedi questo, Chrome funziona!</p></body></html>");
+            }
+
+            // Test generazione PDF
+            ProcessBuilder pb = new ProcessBuilder(
+                    chromePath,
+                    "--headless",
+                    "--disable-gpu",
+                    "--no-sandbox",
+                    "--disable-dev-shm-usage",
+                    "--print-to-pdf=" + tempPdf.getAbsolutePath(),
+                    "--print-to-pdf-no-header",
+                    "file://" + tempHtml.getAbsolutePath()
+            );
+
             Process process = pb.start();
+            boolean finished = process.waitFor(10, java.util.concurrent.TimeUnit.SECONDS);
+
+            boolean success = finished && process.exitValue() == 0 && tempPdf.exists() && tempPdf.length() > 0;
 
-            int exitCode = process.waitFor();
-            return exitCode == 0;
+            // Cleanup
+            tempHtml.delete();
+            tempPdf.delete();
+
+            return success;
+
         } catch (Exception e) {
-            logger.debug("Test Chrome fallito: {}", e.getMessage());
+            logger.debug("Test PDF generation fallito: {}", e.getMessage());
             return false;
         }
     }
 
-    /**
-     * Verifica se un percorso rappresenta un eseguibile valido e accessibile.
-     *
-     * @param path Il percorso da verificare
-     * @return true se il percorso è un file eseguibile valido, false altrimenti
-     */
+    private static void logAvailableBrowsers() {
+        logger.info("🔍 Browser disponibili nel container:");
+        try {
+            Process process = Runtime.getRuntime().exec(new String[]{"ls", "-la", "/usr/bin/"});
+            try (java.io.BufferedReader reader = new java.io.BufferedReader(
+                    new java.io.InputStreamReader(process.getInputStream()))) {
+                reader.lines()
+                        .filter(line -> line.contains("chrome") || line.contains("chromium"))
+                        .forEach(line -> logger.info("  📁 {}", line));
+            }
+
+            // Controlla anche /opt/chrome/
+            File optChrome = new File("/opt/chrome/chrome");
+            if (optChrome.exists()) {
+                logger.info("  📁 /opt/chrome/chrome exists: {}", optChrome.canExecute() ? "executable" : "not executable");
+            }
+
+        } catch (Exception e) {
+            logger.error("Impossibile listare browser: {}", e.getMessage());
+        }
+    }
+
     private static boolean isValidExecutable(String path) {
         if (path == null || path.trim().isEmpty()) {
             return false;
         }
 
         File file = new File(path);
-        return file.exists() && file.canExecute();
-    }
+        boolean valid = file.exists() && file.canExecute();
+
+        if (!valid) {
+            logger.debug("Path non valido: {} (exists: {}, executable: {})",
+                    path, file.exists(), file.canExecute());
+        }
 
-    /**
-     * Verifica se Chrome è disponibile e configurato correttamente.
-     *
-     * @return true se Chrome è disponibile per l'uso, false altrimenti
-     */
+        return valid;
+    }
+
     public boolean isChromeAvailable() {
         return chromePath != null;
     }
 
-    /**
-     * Restituisce il percorso dell'eseguibile Chrome configurato.
-     *
-     * @return Il percorso assoluto di Chrome, o null se non disponibile
-     */
     public String getChromePath() {
         return chromePath;
     }
 
     /**
-     * Restituisce gli argomenti di Chrome ottimizzati per Docker.
-     *
-     * @return Array di argomenti per Chrome
+     * Restituisce gli argomenti Chrome ottimizzati per il container
      */
     public String[] getChromeArgs() {
         try {
             Properties config = loadConfig();
-            String args = config.getProperty("chrome.args",
-                    "--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --remote-debugging-port=0");
-            return args.split("\\s+");
+            String args = config.getProperty("chrome.args");
+
+            if (args != null && !args.trim().isEmpty()) {
+                logger.debug("Argomenti Chrome dal config: {}", args);
+                return args.split("\\s+");
+            }
         } catch (Exception e) {
-            logger.warn("Errore caricamento argomenti Chrome, uso default: {}", e.getMessage());
-            return new String[]{"--headless", "--disable-gpu", "--no-sandbox", "--disable-dev-shm-usage"};
+            logger.warn("Errore caricamento argomenti Chrome: {}", e.getMessage());
         }
+
+        // Fallback con argomenti essenziali per container
+        String[] defaultArgs = {
+                "--headless",
+                "--disable-gpu",
+                "--no-sandbox",
+                "--disable-dev-shm-usage",
+                "--disable-web-security",
+                "--allow-file-access-from-files",
+                "--virtual-time-budget=30000"
+        };
+
+        logger.debug("Argomenti Chrome default container: {}", String.join(" ", defaultArgs));
+        return defaultArgs;
     }
 
-    /**
-     * Valida che Chrome sia disponibile e funzionante eseguendo un test completo.
-     *
-     * @throws IOException Se Chrome non è disponibile o non risponde correttamente
-     */
     public void validateChrome() throws IOException {
         if (!isChromeAvailable()) {
-            throw new IOException("Chrome non disponibile per conversione PDF - Verifica installazione Docker");
+            throw new IOException("Chrome non disponibile nel container per conversione PDF");
         }
 
-        // Test più approfondito con timeout
+        // Test approfondito
         try {
             ProcessBuilder pb = new ProcessBuilder(chromePath, "--version");
-            pb.redirectErrorStream(true);
             Process process = pb.start();
 
             boolean finished = process.waitFor(10, java.util.concurrent.TimeUnit.SECONDS);
 
             if (!finished) {
                 process.destroyForcibly();
-                throw new IOException("Chrome non risponde entro il timeout");
+                throw new IOException("Chrome non risponde entro il timeout nel container");
             }
 
             if (process.exitValue() != 0) {
-                throw new IOException("Chrome restituisce codice di errore: " + process.exitValue());
+                throw new IOException("Chrome restituisce codice errore: " + process.exitValue());
             }
 
-            logger.info("Chrome validato con successo: {}", chromePath);
+            logger.info("Chrome validato con successo nel container: {}", chromePath);
 
         } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
@@ -317,15 +323,11 @@
     }
 
     /**
-     * Crea un ProcessBuilder configurato per Chrome con argomenti ottimizzati per Docker.
-     *
-     * @param additionalArgs Argomenti aggiuntivi specifici per l'operazione
-     * @return ProcessBuilder configurato
-     * @throws IOException Se Chrome non è disponibile
+     * Crea ProcessBuilder con tutti i parametri ottimizzati per container
      */
     public ProcessBuilder createChromeProcess(String... additionalArgs) throws IOException {
         if (!isChromeAvailable()) {
-            throw new IOException("Chrome non disponibile");
+            throw new IOException("Chrome non disponibile nel container");
         }
 
         String[] baseArgs = getChromeArgs();
@@ -338,6 +340,8 @@
         ProcessBuilder pb = new ProcessBuilder(allArgs);
         pb.redirectErrorStream(true);
 
+        logger.debug("Chrome command: {}", String.join(" ", allArgs));
+
         return pb;
     }
 }
\ No newline at end of file
Index: src/main/java/webService/server/converters/mailConverters/MSGtoPDFconverter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package webService.server.converters.mailConverters;\n\nimport webService.server.configuration.configHandlers.conversionContext.ConversionContextReader;\nimport webService.server.converters.Converter;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.poi.hsmf.MAPIMessage;\nimport org.apache.poi.hsmf.datatypes.AttachmentChunks;\nimport org.apache.poi.hsmf.exceptions.ChunkNotFoundException;\nimport webService.server.converters.PDFWatermarkApplier;\nimport webService.server.converters.exception.WatermarkException;\n\nimport java.awt.Desktop;\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.StandardCopyOption;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Convertitore MSG to PDF usando Chrome/Chromium headless nativo.\n * Implementa l'approccio: MSG → HTML → PDF tramite Chrome --headless.\n * Utilizza Apache POI per il parsing dei file MSG di Outlook e supporta\n * l'estrazione di immagini embedded e diversi tipi di contenuto (HTML, RTF, plain text).\n */\npublic class MSGtoPDFconverter extends Converter {\n\n    private static final Logger logger = LogManager.getLogger(MSGtoPDFconverter.class);\n    private Map<String, String> embeddedImages = new HashMap<String, String>();\n    private File tempDir;\n    private String originalBaseName;\n\n    private static final boolean DEBUG_OPEN_HTML_IN_BROWSER = false;\n    private static final boolean DEBUG_KEEP_TEMP_FILES = true; // Mantenuto TRUE per evitare il cleanup\n\n    /**\n     * Converte un file MSG in PDF utilizzando Chrome Headless.\n     * Il processo include parsing del file MSG, estrazione immagini embedded,\n     * generazione HTML e conversione finale in PDF.\n     *\n     * @param msgFile Il file MSG da convertire\n     * @return Il file PDF generato\n     * @throws IOException Se si verificano errori durante la conversione\n     */\n    @Override\n    public File convert(File msgFile) throws IOException {\n        if (msgFile == null || !msgFile.exists()) {\n            throw new FileNotFoundException(\"File MSG non trovato: \" + msgFile);\n        }\n\n        logger.info(\"Inizio conversione MSG to PDF con Chrome Headless: {}\", msgFile.getName());\n\n        tempDir = new File(msgFile.getParent());\n\n        try {\n            MAPIMessage message = parseMsgMessage(msgFile);\n            extractEmbeddedImages(message);\n            File htmlFile = generateCompleteHtml(message);\n\n            // Debug: apri HTML nel browser se richiesto\n            if (DEBUG_OPEN_HTML_IN_BROWSER) {\n                openHtmlInBrowser(htmlFile, ChromeManager.getInstance().getChromePath());\n            }\n\n            File pdfFile = convertHtmlToPdfWithChrome(htmlFile);\n\n            logger.info(\"Conversione completata: {}\", pdfFile.getName());\n\n\n            if (!ConversionContextReader.getWatermark().isEmpty()) {\n                logger.info(\"Applying watermark to PDF...\");\n\n                // Crea un file temporaneo per il PDF con watermark nella stessa directory\n                File tempFile = new File(pdfFile.getParent(), \"watermarked_\" + pdfFile.getName());\n\n                logger.info(\"Original file: {}\", pdfFile.getAbsolutePath());\n                logger.info(\"Temp file for watermark: {}\", tempFile.getAbsolutePath());\n\n                try {\n                    boolean success = PDFWatermarkApplier.applyWatermark(\n                            pdfFile,\n                            tempFile,\n                            ConversionContextReader.getWatermark()\n                    );\n\n                    logger.info(\"Watermark application completed, success: {}\", success);\n\n                    if (success && tempFile.exists() && tempFile.length() > 0) {\n                        logger.info(\"Watermark applied successfully, replacing original file\");\n\n                        //Usa Files.move() per sostituzione atomica\n                        try {\n                            Files.move(tempFile.toPath(), pdfFile.toPath(),\n                                    StandardCopyOption.REPLACE_EXISTING);\n                            logger.info(\"File watermarkato sostituito correttamente\");\n                            return pdfFile; // Ritorna sempre pdfFile\n                        } catch (IOException e) {\n                            logger.warn(\"Impossibile sostituire il file: {}\", e.getMessage());\n                            throw new WatermarkException(\"Impossibile sostituire il file con watermark: \" + e.getMessage());\n                        }\n                    } else {\n                        logger.warn(\"Watermark application failed - temp file not created or empty\");\n                        throw new WatermarkException(\"Watermark non applicato correttamente\");\n                    }\n                } catch (Exception e) {\n                    throw new WatermarkException(\"Impossibile applicare il watermark: \" + e.getMessage());\n                }\n            }\n\n            return pdfFile;\n\n        } catch (Exception e) {\n            logger.error(\"Errore durante la conversione MSG\", e);\n            throw new IOException(\"Errore durante la conversione MSG: \" + e.getMessage(), e);\n        }\n//        finally {\n//            if (!DEBUG_KEEP_TEMP_FILES) {\n//                cleanup();\n//                logger.info(\"File temporanei eliminati.\");\n//            } else {\n//                logger.info(\"File temporanei mantenuti per debugging nella directory: {}\", tempDir.getAbsolutePath());\n//            }\n//        }\n    }\n\n    /**\n     * Effettua il parsing del file MSG utilizzando Apache POI HSMF.\n     *\n     * @param msgFile Il file MSG da analizzare\n     * @return L'oggetto MAPIMessage contenente i dati parsati dell'email\n     * @throws IOException Se si verificano errori durante il parsing\n     */\n    private MAPIMessage parseMsgMessage(File msgFile) throws IOException {\n        try {\n            return new MAPIMessage(msgFile.getAbsolutePath());\n        } catch (Exception e) {\n            throw new IOException(\"Errore nel parsing del file MSG: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Converte il file HTML in PDF utilizzando Chrome Headless.\n     * Configura tutti i parametri necessari per una conversione di qualità\n     * e gestisce l'esecuzione del processo Chrome.\n     *\n     * @param htmlFile Il file HTML da convertire\n     * @return Il file PDF generato\n     * @throws IOException Se Chrome non è disponibile o la conversione fallisce\n     * @throws InterruptedException Se il processo viene interrotto\n     */\n    private File convertHtmlToPdfWithChrome(File htmlFile) throws IOException, InterruptedException {\n        String chromePath = ChromeManager.getInstance().getChromePath();\n        if (chromePath == null) {\n            throw new IOException(\"Chrome non disponibile tramite ChromeManager\");\n        }\n\n        File pdfFile = new File(tempDir, originalBaseName + \".pdf\");\n\n        List<String> command = new ArrayList<String>();\n        command.add(chromePath);\n        command.add(\"--headless\");\n        command.add(\"--no-sandbox\");\n        command.add(\"--disable-gpu\");\n        command.add(\"--disable-dev-shm-usage\");\n        command.add(\"--disable-extensions\");\n        command.add(\"--disable-plugins\");\n        command.add(\"--run-all-compositor-stages-before-draw\");\n        command.add(\"--virtual-time-budget=10000\");\n        command.add(\"--print-to-pdf=\" + pdfFile.getAbsolutePath());\n        command.add(\"--print-to-pdf-no-header\");\n        command.add(\"file://\" + htmlFile.getAbsolutePath().replace(\"\\\\\", \"/\"));\n\n        logger.info(\"Esecuzione comando Chrome: {}\", String.join(\" \", command));\n\n        ProcessBuilder pb = new ProcessBuilder(command);\n        pb.redirectErrorStream(true);\n\n        Process process = pb.start();\n\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String line;\n            StringBuilder output = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            if (output.length() > 0) {\n                logger.debug(\"Output Chrome: {}\", output.toString());\n            }\n        }\n\n        int exitCode = process.waitFor();\n\n        if (exitCode != 0) {\n            logger.error(\"Chrome headless failed with exit code: {}. Command: {}\", exitCode, String.join(\" \", command));\n            throw new IOException(\"Chrome headless failed with exit code: \" + exitCode);\n        }\n\n        if (!pdfFile.exists()) {\n            logger.error(\"PDF non generato da Chrome. Percorso atteso: {}\", pdfFile.getAbsolutePath());\n            throw new IOException(\"PDF non generato da Chrome\");\n        }\n\n        return pdfFile;\n    }\n\n    /**\n     * Apre il file HTML generato nel browser per debug e verifica visuale.\n     * Prova prima il browser predefinito del sistema, poi Chrome esplicito.\n     * Questo metodo è chiamato solo se DEBUG_OPEN_HTML_IN_BROWSER è true.\n     *\n     * @param htmlFile Il file HTML da aprire\n     * @param chromePath Il percorso di Chrome da usare come fallback\n     */\n    private void openHtmlInBrowser(File htmlFile, String chromePath) {\n        if (!htmlFile.exists()) {\n            logger.warn(\"Impossibile aprire il file HTML, non esiste: {}\", htmlFile.getAbsolutePath());\n            return;\n        }\n\n        try {\n            if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {\n                Desktop.getDesktop().browse(htmlFile.toURI());\n                logger.info(\"File HTML aperto con il browser predefinito: {}\", htmlFile.getAbsolutePath());\n                return;\n            }\n        } catch (UnsupportedOperationException e) {\n            logger.warn(\"L'operazione 'browse' non è supportata dal Desktop API in questo ambiente. Errore: {}\", e.getMessage());\n        } catch (IOException e) {\n            logger.warn(\"Errore I/O durante l'apertura del file HTML con il browser predefinito: {}\", e.getMessage());\n        }\n\n        if (chromePath != null && new File(chromePath).exists()) {\n            try {\n                List<String> command = new ArrayList<>();\n                command.add(chromePath);\n                command.add(htmlFile.toURI().toString());\n\n                logger.info(\"Tentativo di apertura HTML con Chrome esplicito: {}\", String.join(\" \", command));\n\n                ProcessBuilder pb = new ProcessBuilder(command);\n                pb.redirectErrorStream(true);\n                Process process = pb.start();\n                logger.info(\"Comando di apertura Chrome avviato per: {}\", htmlFile.getAbsolutePath());\n\n            } catch (IOException e) {\n                logger.error(\"Errore durante il tentativo di aprire l'HTML con Chrome esplicito: {}\", e.getMessage());\n            }\n        } else {\n            logger.warn(\"Impossibile aprire l'HTML nel browser: Desktop API non disponibile e percorso Chrome non valido.\");\n        }\n    }\n\n    /**\n     * Genera il file HTML completo dal messaggio MSG parsato.\n     * Include CSS ottimizzato per stampa, gestione responsive e\n     * il contenuto dell'email processato per la conversione PDF.\n     *\n     * @param message L'oggetto MAPIMessage contenente i dati dell'email\n     * @return Il file HTML generato e pronto per la conversione\n     * @throws IOException Se si verificano errori durante la generazione\n     */\n    private File generateCompleteHtml(MAPIMessage message) throws IOException {\n        StringBuilder html = new StringBuilder();\n\n        // Header HTML identico al convertitore EML\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html>\\n\");\n        html.append(\"<head>\\n\");\n        html.append(\"    <meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\">\\n\");\n        html.append(\"    <title>Email PDF</title>\\n\");\n        html.append(\"    <style>\\n\");\n        html.append(\"        @page {\\n\");\n        html.append(\"            size: A4;\\n\");\n        html.append(\"            margin: 0;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        html, body {\\n\");\n        html.append(\"            margin: 0;\\n\");\n        html.append(\"            padding: 0;\\n\");\n        html.append(\"            height: 100%;\\n\");\n        html.append(\"            width: 100%;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        * {\\n\");\n        html.append(\"            box-sizing: border-box;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        body {\\n\");\n        html.append(\"            font-family: 'Segoe UI', Arial, sans-serif;\\n\");\n        html.append(\"            font-size: 11px;\\n\");\n        html.append(\"            line-height: 1.4;\\n\");\n        html.append(\"            color: #333;\\n\");\n        html.append(\"            background: white;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        .email-content {\\n\");\n        html.append(\"            max-width: 100%;\\n\");\n        html.append(\"            word-wrap: break-word;\\n\");\n        html.append(\"            overflow-wrap: break-word;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        img {\\n\");\n        html.append(\"            max-width: 100%;\\n\");\n        html.append(\"            height: auto;\\n\");\n        html.append(\"            display: block;\\n\");\n        html.append(\"            margin: 8px 0;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        table {\\n\");\n        html.append(\"            border-collapse: collapse;\\n\");\n        html.append(\"            width: 100%;\\n\");\n        html.append(\"            margin: 8px 0;\\n\");\n        html.append(\"            font-size: inherit;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        td, th {\\n\");\n        html.append(\"            padding: 6px;\\n\");\n        html.append(\"            vertical-align: top;\\n\");\n        html.append(\"            border: 1px solid #ddd;\\n\");\n        html.append(\"            word-wrap: break-word;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        .no-print {\\n\");\n        html.append(\"            display: none !important;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        table table {\\n\");\n        html.append(\"            border: none;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        table table td {\\n\");\n        html.append(\"            border: none;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        @media print {\\n\");\n        html.append(\"            body::before, body::after {\\n\");\n        html.append(\"                content: none !important;\\n\");\n        html.append(\"                display: none !important;\\n\");\n        html.append(\"            }\\n\");\n        html.append(\"            @page {\\n\");\n        html.append(\"                margin: 0 !important;\\n\");\n        html.append(\"            }\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"    </style>\\n\");\n        html.append(\"</head>\\n\");\n        html.append(\"<body>\\n\");\n\n        // Contenuto email senza header (come nel convertitore EML)\n        html.append(\"<div class=\\\"email-content\\\">\");\n        appendMsgContent(html, message);\n        html.append(\"</div>\");\n\n        html.append(\"</body></html>\");\n\n        File htmlFile = new File(tempDir, \"email.html\");\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(htmlFile), StandardCharsets.UTF_8)) {\n            writer.write(html.toString());\n        }\n\n        logger.info(\"HTML generato: {}\", htmlFile.getAbsolutePath());\n        return htmlFile;\n    }\n\n    /**\n     * Estrae e formatta il contenuto del messaggio MSG nell'HTML.\n     * Prova in ordine: HTML body, RTF body convertito, text body.\n     * Gestisce automaticamente i diversi formati di contenuto supportati da Outlook.\n     *\n     * @param html Il StringBuilder dove aggiungere l'HTML del contenuto\n     * @param message L'oggetto MAPIMessage da processare\n     * @throws IOException Se si verificano errori durante l'estrazione del contenuto\n     */\n    private void appendMsgContent(StringBuilder html, MAPIMessage message) throws IOException {\n        try {\n            // Prova prima HTML body\n            String htmlBody = message.getHtmlBody();\n            if (htmlBody != null && !htmlBody.trim().isEmpty()) {\n                String processedHtml = processCidReferences(htmlBody);\n                html.append(processedHtml);\n                logger.info(\"Usato HTML body del MSG\");\n                return;\n            }\n        } catch (ChunkNotFoundException e) {\n            logger.debug(\"HTML body non trovato nel MSG, provo RTF body\");\n        }\n\n        try {\n            // Fallback su RTF body convertito in testo\n            String rtfBody = message.getRtfBody();\n            if (rtfBody != null && !rtfBody.trim().isEmpty()) {\n                // Conversione molto semplice RTF -> HTML\n                String convertedHtml = convertRtfToHtml(rtfBody);\n                html.append(convertedHtml);\n                logger.info(\"Usato RTF body del MSG convertito\");\n                return;\n            }\n        } catch (ChunkNotFoundException e) {\n            logger.debug(\"RTF body non trovato nel MSG, provo text body\");\n        }\n\n        try {\n            // Fallback finale su text body\n            String textBody = message.getTextBody();\n            if (textBody != null && !textBody.trim().isEmpty()) {\n                html.append(\"<pre style=\\\"white-space: pre-wrap; font-family: inherit;\\\">\")\n                        .append(escapeHtml(textBody))\n                        .append(\"</pre>\");\n                logger.info(\"Usato text body del MSG\");\n                return;\n            }\n        } catch (ChunkNotFoundException e) {\n            logger.warn(\"Nessun body trovato nel MSG\");\n        }\n\n        // Se non c'è contenuto\n        html.append(\"<p><em>Nessun contenuto disponibile</em></p>\");\n    }\n\n    /**\n     * Estrae le immagini embedded dagli allegati del messaggio MSG.\n     * Analizza tutti gli allegati, identifica quelli con MIME type image/*\n     * e li salva come file temporanei per il riferimento nell'HTML.\n     *\n     * @param message L'oggetto MAPIMessage da cui estrarre le immagini\n     * @throws IOException Se si verificano errori durante l'estrazione\n     * @throws ChunkNotFoundException Se i chunks degli allegati non sono trovati\n     */\n    private void extractEmbeddedImages(MAPIMessage message) throws IOException, ChunkNotFoundException {\n        AttachmentChunks[] attachments = message.getAttachmentFiles();\n        if (attachments == null) return;\n\n        for (int i = 0; i < attachments.length; i++) {\n            AttachmentChunks attachment = attachments[i];\n\n            try {\n                // Controlla se è un'immagine embedded\n                String fileName = getAttachmentFileName(attachment);\n                String mimeType = getAttachmentMimeType(attachment);\n\n                if (mimeType != null && mimeType.startsWith(\"image/\")) {\n                    byte[] attachmentData = attachment.getEmbeddedAttachmentObject();\n                    if (attachmentData != null) {\n                        saveEmbeddedImageFromAttachment(attachmentData, fileName, mimeType, i);\n                    }\n                }\n            } catch (Exception e) {\n                logger.warn(\"Errore nell'estrazione allegato {}: {}\", i, e.getMessage());\n            }\n        }\n    }\n\n    /**\n     * Estrae il nome del file da un allegato MSG.\n     * Prova prima il nome lungo, poi il nome corto come fallback.\n     *\n     * @param attachment L'oggetto AttachmentChunks da cui estrarre il nome\n     * @return Il nome del file, o \"attachment\" come default\n     */\n    private String getAttachmentFileName(AttachmentChunks attachment) {\n        try {\n            if (attachment.getAttachLongFileName() != null) {\n                return attachment.getAttachLongFileName().toString();\n            }\n            if (attachment.getAttachFileName() != null) {\n                return attachment.getAttachFileName().toString();\n            }\n        } catch (Exception e) {\n            logger.debug(\"Errore nel recupero nome allegato: {}\", e.getMessage());\n        }\n        return \"attachment\";\n    }\n\n    /**\n     * Estrae il MIME type da un allegato MSG.\n     *\n     * @param attachment L'oggetto AttachmentChunks da cui estrarre il MIME type\n     * @return Il MIME type dell'allegato, o null se non disponibile\n     */\n    private String getAttachmentMimeType(AttachmentChunks attachment) {\n        try {\n            if (attachment.getAttachMimeTag() != null) {\n                return attachment.getAttachMimeTag().toString();\n            }\n        } catch (Exception e) {\n            logger.debug(\"Errore nel recupero MIME type allegato: {}\", e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Salva un'immagine embedded da un allegato MSG.\n     * Crea un file temporaneo con nome sicuro e mappa i vari formati\n     * di Content-ID per i riferimenti HTML.\n     *\n     * @param imageData I dati binari dell'immagine\n     * @param fileName Il nome originale del file allegato\n     * @param mimeType Il MIME type dell'immagine\n     * @param index L'indice dell'allegato per creare nomi univoci\n     * @throws IOException Se si verificano errori durante il salvataggio\n     */\n    private void saveEmbeddedImageFromAttachment(byte[] imageData, String fileName, String mimeType, int index) throws IOException {\n        String extension = getImageExtension(mimeType);\n        String safeFileName = \"embedded_\" + index + \".\" + extension;\n\n        File imageFile = new File(tempDir, safeFileName);\n        try (FileOutputStream fos = new FileOutputStream(imageFile)) {\n            fos.write(imageData);\n        }\n\n        // Mappa per riferimenti CID (usa diversi formati possibili)\n        String contentId = fileName.replaceAll(\"[^a-zA-Z0-9._-]\", \"_\");\n        embeddedImages.put(contentId, imageFile.getAbsolutePath());\n        embeddedImages.put(\"cid:\" + contentId, imageFile.getAbsolutePath());\n        embeddedImages.put(\"<\" + contentId + \">\", imageFile.getAbsolutePath());\n\n        logger.info(\"Immagine MSG salvata: {} -> {}\", fileName, safeFileName);\n    }\n\n    /**\n     * Converte contenuto RTF in HTML usando un approccio semplificato.\n     * Rimuove i comandi RTF base e mantiene il testo leggibile,\n     * convertendo i line break in tag HTML appropriati.\n     *\n     * @param rtfBody Il contenuto RTF da convertire\n     * @return L'HTML generato dal contenuto RTF\n     */\n    private String convertRtfToHtml(String rtfBody) {\n        // Conversione molto semplice RTF -> HTML\n        // Rimuove i comandi RTF base e mantiene il testo\n        String text = rtfBody;\n\n        // Rimuove header RTF\n        text = text.replaceAll(\"\\\\{\\\\\\\\rtf1[^}]*\\\\}\", \"\");\n\n        // Rimuove comandi di formattazione RTF\n        text = text.replaceAll(\"\\\\\\\\[a-z]+\\\\d*\", \"\");\n        text = text.replaceAll(\"\\\\{|\\\\}\", \"\");\n\n        // Pulisce spazi multipli\n        text = text.replaceAll(\"\\\\s+\", \" \").trim();\n\n        // Converte newline in <br>\n        text = text.replace(\"\\n\", \"<br>\");\n\n        return \"<div>\" + escapeHtml(text) + \"</div>\";\n    }\n\n    /**\n     * Processa i riferimenti CID nell'HTML sostituendoli con percorsi file locali.\n     * Gestisce diversi formati di riferimento CID utilizzati da Outlook.\n     *\n     * @param htmlContent Il contenuto HTML da processare\n     * @return L'HTML con i riferimenti CID sostituiti con percorsi locali\n     */\n    private String processCidReferences(String htmlContent) {\n        String processed = htmlContent;\n\n        for (Map.Entry<String, String> entry : embeddedImages.entrySet()) {\n            String contentId = entry.getKey();\n            String localPath = \"file:///\" + entry.getValue().replace(\"\\\\\", \"/\");\n\n            // Sostituisci vari formati di riferimento\n            processed = processed.replaceAll(\n                    \"src=[\\\"']cid:\" + contentId + \"[\\\"']\",\n                    \"src=\\\"\" + localPath + \"\\\"\"\n            );\n            processed = processed.replaceAll(\n                    \"src=[\\\"']\" + contentId + \"[\\\"']\",\n                    \"src=\\\"\" + localPath + \"\\\"\"\n            );\n        }\n\n        return processed;\n    }\n\n    /**\n     * Converte un tipo MIME in estensione file appropriata per le immagini.\n     *\n     * @param mimeType Il tipo MIME da convertire\n     * @return L'estensione file corrispondente, o \"img\" come default\n     */\n    private String getImageExtension(String mimeType) {\n        if (mimeType == null) return \"img\";\n        String lowerType = mimeType.toLowerCase();\n        if (\"image/gif\".equals(lowerType)) {\n            return \"gif\";\n        } else if (\"image/jpeg\".equals(lowerType)) {\n            return \"jpg\";\n        } else if (\"image/png\".equals(lowerType)) {\n            return \"png\";\n        } else if (\"image/bmp\".equals(lowerType)) {\n            return \"bmp\";\n        } else if (\"image/webp\".equals(lowerType)) {\n            return \"webp\";\n        } else {\n            return \"img\";\n        }\n    }\n\n    /**\n     * Effettua l'escape dei caratteri HTML speciali per evitare problemi di rendering.\n     *\n     * @param text Il testo da processare\n     * @return Il testo con i caratteri HTML escapati, o stringa vuota se null\n     */\n    private String escapeHtml(String text) {\n        if (text == null) return \"\";\n        return text.replace(\"&\", \"&amp;\")\n                .replace(\"<\", \"&lt;\")\n                .replace(\">\", \"&gt;\")\n                .replace(\"\\\"\", \"&quot;\")\n                .replace(\"'\", \"&#39;\");\n    }\n\n    @Deprecated\n    /**\n     * Pulisce i file temporanei e la directory di lavoro.\n     * Elimina tutti i file nella directory temporanea e poi la directory stessa.\n     * Viene chiamato nel blocco finally se DEBUG_KEEP_TEMP_FILES è false.\n     */\n    private void cleanup() {\n        if (tempDir != null && tempDir.exists()) {\n            File[] files = tempDir.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    if (!file.delete()) {\n                        logger.warn(\"Impossibile eliminare il file temporaneo: {}\", file.getAbsolutePath());\n                    }\n                }\n            }\n            if (!tempDir.delete()) {\n                logger.warn(\"Impossibile eliminare la directory temporanea: {}\", tempDir.getAbsolutePath());\n            }\n        }\n        embeddedImages.clear();\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/webService/server/converters/mailConverters/MSGtoPDFconverter.java b/src/main/java/webService/server/converters/mailConverters/MSGtoPDFconverter.java
--- a/src/main/java/webService/server/converters/mailConverters/MSGtoPDFconverter.java	(revision c03fcda81ec80ee23b4f0e9aa9b8f8e2a00cc447)
+++ b/src/main/java/webService/server/converters/mailConverters/MSGtoPDFconverter.java	(date 1751445894577)
@@ -8,131 +8,57 @@
 import org.apache.poi.hsmf.datatypes.AttachmentChunks;
 import org.apache.poi.hsmf.exceptions.ChunkNotFoundException;
 import webService.server.converters.PDFWatermarkApplier;
+import webService.server.converters.exception.ConversionException;
 import webService.server.converters.exception.WatermarkException;
 
-import java.awt.Desktop;
 import java.io.*;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.StandardCopyOption;
-import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
 /**
- * Convertitore MSG to PDF usando Chrome/Chromium headless nativo.
- * Implementa l'approccio: MSG → HTML → PDF tramite Chrome --headless.
- * Utilizza Apache POI per il parsing dei file MSG di Outlook e supporta
- * l'estrazione di immagini embedded e diversi tipi di contenuto (HTML, RTF, plain text).
+ * Convertitore MSG to PDF usando Chrome Headless nel container Docker.
+ * Ottimizzato per il setup Docker con Chrome for Testing.
  */
 public class MSGtoPDFconverter extends Converter {
 
     private static final Logger logger = LogManager.getLogger(MSGtoPDFconverter.class);
-    private Map<String, String> embeddedImages = new HashMap<String, String>();
+    private Map<String, String> embeddedImages = new HashMap<>();
     private File tempDir;
     private String originalBaseName;
 
-    private static final boolean DEBUG_OPEN_HTML_IN_BROWSER = false;
-    private static final boolean DEBUG_KEEP_TEMP_FILES = true; // Mantenuto TRUE per evitare il cleanup
+    private static final boolean DEBUG_KEEP_TEMP_FILES = true;
 
-    /**
-     * Converte un file MSG in PDF utilizzando Chrome Headless.
-     * Il processo include parsing del file MSG, estrazione immagini embedded,
-     * generazione HTML e conversione finale in PDF.
-     *
-     * @param msgFile Il file MSG da convertire
-     * @return Il file PDF generato
-     * @throws IOException Se si verificano errori durante la conversione
-     */
     @Override
-    public File convert(File msgFile) throws IOException {
+    public File convert(File msgFile) throws IOException, WatermarkException {
         if (msgFile == null || !msgFile.exists()) {
             throw new FileNotFoundException("File MSG non trovato: " + msgFile);
         }
 
-        logger.info("Inizio conversione MSG to PDF con Chrome Headless: {}", msgFile.getName());
+        logger.info("🚀 Inizio conversione MSG to PDF: {}", msgFile.getName());
 
         tempDir = new File(msgFile.getParent());
+        originalBaseName = msgFile.getName().replaceAll("\\.[^.]*$", "");
 
         try {
             MAPIMessage message = parseMsgMessage(msgFile);
             extractEmbeddedImages(message);
             File htmlFile = generateCompleteHtml(message);
 
-            // Debug: apri HTML nel browser se richiesto
-            if (DEBUG_OPEN_HTML_IN_BROWSER) {
-                openHtmlInBrowser(htmlFile, ChromeManager.getInstance().getChromePath());
-            }
-
             File pdfFile = convertHtmlToPdfWithChrome(htmlFile);
 
-            logger.info("Conversione completata: {}", pdfFile.getName());
-
-
-            if (!ConversionContextReader.getWatermark().isEmpty()) {
-                logger.info("Applying watermark to PDF...");
-
-                // Crea un file temporaneo per il PDF con watermark nella stessa directory
-                File tempFile = new File(pdfFile.getParent(), "watermarked_" + pdfFile.getName());
-
-                logger.info("Original file: {}", pdfFile.getAbsolutePath());
-                logger.info("Temp file for watermark: {}", tempFile.getAbsolutePath());
-
-                try {
-                    boolean success = PDFWatermarkApplier.applyWatermark(
-                            pdfFile,
-                            tempFile,
-                            ConversionContextReader.getWatermark()
-                    );
-
-                    logger.info("Watermark application completed, success: {}", success);
-
-                    if (success && tempFile.exists() && tempFile.length() > 0) {
-                        logger.info("Watermark applied successfully, replacing original file");
-
-                        //Usa Files.move() per sostituzione atomica
-                        try {
-                            Files.move(tempFile.toPath(), pdfFile.toPath(),
-                                    StandardCopyOption.REPLACE_EXISTING);
-                            logger.info("File watermarkato sostituito correttamente");
-                            return pdfFile; // Ritorna sempre pdfFile
-                        } catch (IOException e) {
-                            logger.warn("Impossibile sostituire il file: {}", e.getMessage());
-                            throw new WatermarkException("Impossibile sostituire il file con watermark: " + e.getMessage());
-                        }
-                    } else {
-                        logger.warn("Watermark application failed - temp file not created or empty");
-                        throw new WatermarkException("Watermark non applicato correttamente");
-                    }
-                } catch (Exception e) {
-                    throw new WatermarkException("Impossibile applicare il watermark: " + e.getMessage());
-                }
-            }
+            logger.info("Conversione MSG completata: {}", pdfFile.getName());
 
             return pdfFile;
 
         } catch (Exception e) {
-            logger.error("Errore durante la conversione MSG", e);
-            throw new IOException("Errore durante la conversione MSG: " + e.getMessage(), e);
+            logger.error("Errore durante conversione MSG", e);
+            throw new IOException("Errore durante conversione MSG: " + e.getMessage(), e);
         }
-//        finally {
-//            if (!DEBUG_KEEP_TEMP_FILES) {
-//                cleanup();
-//                logger.info("File temporanei eliminati.");
-//            } else {
-//                logger.info("File temporanei mantenuti per debugging nella directory: {}", tempDir.getAbsolutePath());
-//            }
-//        }
     }
 
-    /**
-     * Effettua il parsing del file MSG utilizzando Apache POI HSMF.
-     *
-     * @param msgFile Il file MSG da analizzare
-     * @return L'oggetto MAPIMessage contenente i dati parsati dell'email
-     * @throws IOException Se si verificano errori durante il parsing
-     */
     private MAPIMessage parseMsgMessage(File msgFile) throws IOException {
         try {
             return new MAPIMessage(msgFile.getAbsolutePath());
@@ -141,131 +67,61 @@
         }
     }
 
-    /**
-     * Converte il file HTML in PDF utilizzando Chrome Headless.
-     * Configura tutti i parametri necessari per una conversione di qualità
-     * e gestisce l'esecuzione del processo Chrome.
-     *
-     * @param htmlFile Il file HTML da convertire
-     * @return Il file PDF generato
-     * @throws IOException Se Chrome non è disponibile o la conversione fallisce
-     * @throws InterruptedException Se il processo viene interrotto
-     */
     private File convertHtmlToPdfWithChrome(File htmlFile) throws IOException, InterruptedException {
-        String chromePath = ChromeManager.getInstance().getChromePath();
-        if (chromePath == null) {
-            throw new IOException("Chrome non disponibile tramite ChromeManager");
+        ChromeManager chromeManager = ChromeManager.getInstance();
+        if (!chromeManager.isChromeAvailable()) {
+            throw new IOException("Chrome non disponibile nel container");
         }
 
         File pdfFile = new File(tempDir, originalBaseName + ".pdf");
 
-        List<String> command = new ArrayList<String>();
-        command.add(chromePath);
-        command.add("--headless");
-        command.add("--no-sandbox");
-        command.add("--disable-gpu");
-        command.add("--disable-dev-shm-usage");
-        command.add("--disable-extensions");
-        command.add("--disable-plugins");
-        command.add("--run-all-compositor-stages-before-draw");
-        command.add("--virtual-time-budget=10000");
-        command.add("--print-to-pdf=" + pdfFile.getAbsolutePath());
-        command.add("--print-to-pdf-no-header");
-        command.add("file://" + htmlFile.getAbsolutePath().replace("\\", "/"));
-
-        logger.info("Esecuzione comando Chrome: {}", String.join(" ", command));
+        try {
+            ProcessBuilder pb = chromeManager.createChromeProcess(
+                    "--print-to-pdf=" + pdfFile.getAbsolutePath(),
+                    "--print-to-pdf-no-header",
+                    "file://" + htmlFile.getAbsolutePath().replace("\\", "/")
+            );
 
-        ProcessBuilder pb = new ProcessBuilder(command);
-        pb.redirectErrorStream(true);
-
-        Process process = pb.start();
+            logger.info("Avvio Chrome per conversione MSG PDF...");
+            Process process = pb.start();
 
-        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
-            String line;
-            StringBuilder output = new StringBuilder();
-            while ((line = reader.readLine()) != null) {
-                output.append(line).append("\n");
-            }
-            if (output.length() > 0) {
-                logger.debug("Output Chrome: {}", output.toString());
-            }
-        }
+            // Log output Chrome
+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
+                String line;
+                StringBuilder output = new StringBuilder();
+                while ((line = reader.readLine()) != null) {
+                    output.append(line).append("\n");
+                }
+                if (output.length() > 0) {
+                    logger.debug("Chrome output: {}", output.toString());
+                }
+            }
 
-        int exitCode = process.waitFor();
+            int exitCode = process.waitFor();
 
-        if (exitCode != 0) {
-            logger.error("Chrome headless failed with exit code: {}. Command: {}", exitCode, String.join(" ", command));
-            throw new IOException("Chrome headless failed with exit code: " + exitCode);
-        }
+            if (exitCode != 0) {
+                logger.error("Chrome failed with exit code: {}", exitCode);
+                throw new IOException("Chrome conversion failed with exit code: " + exitCode);
+            }
 
-        if (!pdfFile.exists()) {
-            logger.error("PDF non generato da Chrome. Percorso atteso: {}", pdfFile.getAbsolutePath());
-            throw new IOException("PDF non generato da Chrome");
-        }
+            if (!pdfFile.exists()) {
+                logger.error("PDF non generato. Path: {}", pdfFile.getAbsolutePath());
+                throw new IOException("PDF file not generated by Chrome");
+            }
 
-        return pdfFile;
-    }
-
-    /**
-     * Apre il file HTML generato nel browser per debug e verifica visuale.
-     * Prova prima il browser predefinito del sistema, poi Chrome esplicito.
-     * Questo metodo è chiamato solo se DEBUG_OPEN_HTML_IN_BROWSER è true.
-     *
-     * @param htmlFile Il file HTML da aprire
-     * @param chromePath Il percorso di Chrome da usare come fallback
-     */
-    private void openHtmlInBrowser(File htmlFile, String chromePath) {
-        if (!htmlFile.exists()) {
-            logger.warn("Impossibile aprire il file HTML, non esiste: {}", htmlFile.getAbsolutePath());
-            return;
-        }
-
-        try {
-            if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
-                Desktop.getDesktop().browse(htmlFile.toURI());
-                logger.info("File HTML aperto con il browser predefinito: {}", htmlFile.getAbsolutePath());
-                return;
-            }
-        } catch (UnsupportedOperationException e) {
-            logger.warn("L'operazione 'browse' non è supportata dal Desktop API in questo ambiente. Errore: {}", e.getMessage());
-        } catch (IOException e) {
-            logger.warn("Errore I/O durante l'apertura del file HTML con il browser predefinito: {}", e.getMessage());
-        }
+            logger.info("PDF MSG generato: {} bytes", pdfFile.length());
+            return pdfFile;
 
-        if (chromePath != null && new File(chromePath).exists()) {
-            try {
-                List<String> command = new ArrayList<>();
-                command.add(chromePath);
-                command.add(htmlFile.toURI().toString());
-
-                logger.info("Tentativo di apertura HTML con Chrome esplicito: {}", String.join(" ", command));
-
-                ProcessBuilder pb = new ProcessBuilder(command);
-                pb.redirectErrorStream(true);
-                Process process = pb.start();
-                logger.info("Comando di apertura Chrome avviato per: {}", htmlFile.getAbsolutePath());
-
-            } catch (IOException e) {
-                logger.error("Errore durante il tentativo di aprire l'HTML con Chrome esplicito: {}", e.getMessage());
-            }
-        } else {
-            logger.warn("Impossibile aprire l'HTML nel browser: Desktop API non disponibile e percorso Chrome non valido.");
+        } catch (Exception e) {
+            logger.error("Errore conversione Chrome MSG", e);
+            throw e;
         }
     }
 
-    /**
-     * Genera il file HTML completo dal messaggio MSG parsato.
-     * Include CSS ottimizzato per stampa, gestione responsive e
-     * il contenuto dell'email processato per la conversione PDF.
-     *
-     * @param message L'oggetto MAPIMessage contenente i dati dell'email
-     * @return Il file HTML generato e pronto per la conversione
-     * @throws IOException Se si verificano errori durante la generazione
-     */
     private File generateCompleteHtml(MAPIMessage message) throws IOException {
         StringBuilder html = new StringBuilder();
 
-        // Header HTML identico al convertitore EML
+        // HTML con CSS ottimizzato per Chrome container
         html.append("<!DOCTYPE html>\n");
         html.append("<html>\n");
         html.append("<head>\n");
@@ -275,31 +131,24 @@
         html.append("    <style>\n");
         html.append("        @page {\n");
         html.append("            size: A4;\n");
-        html.append("            margin: 0;\n");
+        html.append("            margin: 15mm;\n");
         html.append("        }\n");
         html.append("        \n");
         html.append("        html, body {\n");
         html.append("            margin: 0;\n");
         html.append("            padding: 0;\n");
-        html.append("            height: 100%;\n");
-        html.append("            width: 100%;\n");
-        html.append("        }\n");
-        html.append("        \n");
-        html.append("        * {\n");
-        html.append("            box-sizing: border-box;\n");
+        html.append("            font-family: Arial, Helvetica, sans-serif;\n");
+        html.append("            font-size: 12px;\n");
+        html.append("            line-height: 1.5;\n");
+        html.append("            color: #000000;\n");
+        html.append("            background: #ffffff;\n");
         html.append("        }\n");
         html.append("        \n");
-        html.append("        body {\n");
-        html.append("            font-family: 'Segoe UI', Arial, sans-serif;\n");
-        html.append("            font-size: 11px;\n");
-        html.append("            line-height: 1.4;\n");
-        html.append("            color: #333;\n");
-        html.append("            background: white;\n");
-        html.append("        }\n");
         html.append("        .email-content {\n");
         html.append("            max-width: 100%;\n");
         html.append("            word-wrap: break-word;\n");
         html.append("            overflow-wrap: break-word;\n");
+        html.append("            padding: 10px;\n");
         html.append("        }\n");
         html.append("        \n");
         html.append("        img {\n");
@@ -313,7 +162,6 @@
         html.append("            border-collapse: collapse;\n");
         html.append("            width: 100%;\n");
         html.append("            margin: 8px 0;\n");
-        html.append("            font-size: inherit;\n");
         html.append("        }\n");
         html.append("        \n");
         html.append("        td, th {\n");
@@ -322,33 +170,10 @@
         html.append("            border: 1px solid #ddd;\n");
         html.append("            word-wrap: break-word;\n");
         html.append("        }\n");
-        html.append("        \n");
-        html.append("        .no-print {\n");
-        html.append("            display: none !important;\n");
-        html.append("        }\n");
-        html.append("        \n");
-        html.append("        table table {\n");
-        html.append("            border: none;\n");
-        html.append("        }\n");
-        html.append("        \n");
-        html.append("        table table td {\n");
-        html.append("            border: none;\n");
-        html.append("        }\n");
-        html.append("        \n");
-        html.append("        @media print {\n");
-        html.append("            body::before, body::after {\n");
-        html.append("                content: none !important;\n");
-        html.append("                display: none !important;\n");
-        html.append("            }\n");
-        html.append("            @page {\n");
-        html.append("                margin: 0 !important;\n");
-        html.append("            }\n");
-        html.append("        }\n");
         html.append("    </style>\n");
         html.append("</head>\n");
         html.append("<body>\n");
 
-        // Contenuto email senza header (come nel convertitore EML)
         html.append("<div class=\"email-content\">");
         appendMsgContent(html, message);
         html.append("</div>");
@@ -360,105 +185,131 @@
             writer.write(html.toString());
         }
 
-        logger.info("HTML generato: {}", htmlFile.getAbsolutePath());
+        // DEBUG: Log contenuto HTML generato
+        logHtmlContent(htmlFile);
+
         return htmlFile;
     }
 
+    private void logHtmlContent(File htmlFile) {
+        try {
+            byte[] htmlBytes = Files.readAllBytes(htmlFile.toPath());
+            String htmlContent = new String(htmlBytes, StandardCharsets.UTF_8);
+
+            logger.info("=== DEBUG MSG HTML GENERATO ===");
+            logger.info("HTML length: {}", htmlContent.length());
+            logger.info("Contiene contenuto MSG? {}", htmlContent.contains("email-content"));
+
+            // Log preview
+            String preview = htmlContent.length() > 800 ?
+                    htmlContent.substring(0, 800) + "..." : htmlContent;
+            logger.info("MSG HTML preview:\n{}", preview);
+
+        } catch (Exception e) {
+            logger.error("Errore lettura HTML MSG per debug: {}", e.getMessage());
+        }
+    }
+
     /**
-     * Estrae e formatta il contenuto del messaggio MSG nell'HTML.
-     * Prova in ordine: HTML body, RTF body convertito, text body.
-     * Gestisce automaticamente i diversi formati di contenuto supportati da Outlook.
-     *
-     * @param html Il StringBuilder dove aggiungere l'HTML del contenuto
-     * @param message L'oggetto MAPIMessage da processare
-     * @throws IOException Se si verificano errori durante l'estrazione del contenuto
+     * DEBUG VERSION - Include tutti i tipi di contenuto MSG
      */
     private void appendMsgContent(StringBuilder html, MAPIMessage message) throws IOException {
+        logger.info("=== DEBUG MSG CONTENT ===");
+        boolean hasContent = false;
+
         try {
-            // Prova prima HTML body
+            // Prova HTML body
             String htmlBody = message.getHtmlBody();
+            logger.info("📧 HTML Body length: {}", htmlBody != null ? htmlBody.length() : "NULL");
+
             if (htmlBody != null && !htmlBody.trim().isEmpty()) {
                 String processedHtml = processCidReferences(htmlBody);
                 html.append(processedHtml);
                 logger.info("Usato HTML body del MSG");
-                return;
+                hasContent = true;
             }
         } catch (ChunkNotFoundException e) {
             logger.debug("HTML body non trovato nel MSG, provo RTF body");
         }
 
-        try {
-            // Fallback su RTF body convertito in testo
-            String rtfBody = message.getRtfBody();
-            if (rtfBody != null && !rtfBody.trim().isEmpty()) {
-                // Conversione molto semplice RTF -> HTML
-                String convertedHtml = convertRtfToHtml(rtfBody);
-                html.append(convertedHtml);
-                logger.info("Usato RTF body del MSG convertito");
-                return;
-            }
-        } catch (ChunkNotFoundException e) {
-            logger.debug("RTF body non trovato nel MSG, provo text body");
+        if (!hasContent) {
+            try {
+                // Fallback RTF body
+                String rtfBody = message.getRtfBody();
+                logger.info("📧 RTF Body length: {}", rtfBody != null ? rtfBody.length() : "NULL");
+
+                if (rtfBody != null && !rtfBody.trim().isEmpty()) {
+                    String convertedHtml = convertRtfToHtml(rtfBody);
+                    html.append(convertedHtml);
+                    logger.info("Usato RTF body del MSG convertito");
+                    hasContent = true;
+                }
+            } catch (ChunkNotFoundException e) {
+                logger.debug("RTF body non trovato nel MSG, provo text body");
+            }
         }
 
-        try {
-            // Fallback finale su text body
-            String textBody = message.getTextBody();
-            if (textBody != null && !textBody.trim().isEmpty()) {
-                html.append("<pre style=\"white-space: pre-wrap; font-family: inherit;\">")
-                        .append(escapeHtml(textBody))
-                        .append("</pre>");
-                logger.info("Usato text body del MSG");
-                return;
-            }
-        } catch (ChunkNotFoundException e) {
-            logger.warn("Nessun body trovato nel MSG");
+        if (!hasContent) {
+            try {
+                // Fallback text body
+                String textBody = message.getTextBody();
+                logger.info("📧 Text Body length: {}", textBody != null ? textBody.length() : "NULL");
+
+                if (textBody != null && !textBody.trim().isEmpty()) {
+                    html.append("<div style=\"white-space: pre-wrap; font-family: inherit;\">")
+                            .append(escapeHtml(textBody))
+                            .append("</div>");
+                    logger.info("Usato text body del MSG");
+                    hasContent = true;
+                }
+            } catch (ChunkNotFoundException e) {
+                logger.warn("Nessun body trovato nel MSG");
+            }
         }
 
         // Se non c'è contenuto
-        html.append("<p><em>Nessun contenuto disponibile</em></p>");
+        if (!hasContent) {
+            html.append("<div style=\"color: #666; font-style: italic; padding: 20px;\">");
+            html.append("Nessun contenuto testuale disponibile nel file MSG.");
+            html.append("</div>");
+            logger.warn("Nessun contenuto trovato nel MSG");
+        }
+
+        logger.info("=== FINE DEBUG MSG CONTENT ===");
     }
 
-    /**
-     * Estrae le immagini embedded dagli allegati del messaggio MSG.
-     * Analizza tutti gli allegati, identifica quelli con MIME type image/*
-     * e li salva come file temporanei per il riferimento nell'HTML.
-     *
-     * @param message L'oggetto MAPIMessage da cui estrarre le immagini
-     * @throws IOException Se si verificano errori durante l'estrazione
-     * @throws ChunkNotFoundException Se i chunks degli allegati non sono trovati
-     */
-    private void extractEmbeddedImages(MAPIMessage message) throws IOException, ChunkNotFoundException {
-        AttachmentChunks[] attachments = message.getAttachmentFiles();
-        if (attachments == null) return;
+    private void extractEmbeddedImages(MAPIMessage message) throws IOException {
+        try {
+            AttachmentChunks[] attachments = message.getAttachmentFiles();
+            if (attachments == null) {
+                logger.info("📎 Nessun allegato trovato nel MSG");
+                return;
+            }
+
+            logger.info("📎 Trovati {} allegati nel MSG", attachments.length);
 
-        for (int i = 0; i < attachments.length; i++) {
-            AttachmentChunks attachment = attachments[i];
+            for (int i = 0; i < attachments.length; i++) {
+                AttachmentChunks attachment = attachments[i];
 
-            try {
-                // Controlla se è un'immagine embedded
-                String fileName = getAttachmentFileName(attachment);
-                String mimeType = getAttachmentMimeType(attachment);
+                try {
+                    String fileName = getAttachmentFileName(attachment);
+                    String mimeType = getAttachmentMimeType(attachment);
 
-                if (mimeType != null && mimeType.startsWith("image/")) {
-                    byte[] attachmentData = attachment.getEmbeddedAttachmentObject();
-                    if (attachmentData != null) {
-                        saveEmbeddedImageFromAttachment(attachmentData, fileName, mimeType, i);
-                    }
-                }
-            } catch (Exception e) {
-                logger.warn("Errore nell'estrazione allegato {}: {}", i, e.getMessage());
+                    if (mimeType != null && mimeType.startsWith("image/")) {
+                        byte[] attachmentData = attachment.getEmbeddedAttachmentObject();
+                        if (attachmentData != null) {
+                            saveEmbeddedImageFromAttachment(attachmentData, fileName, mimeType, i);
+                        }
+                    }
+                } catch (Exception e) {
+                    logger.warn("Errore estrazione allegato {}: {}", i, e.getMessage());
+                }
             }
+        } catch (ConversionException e) {
+            logger.info("Nessun chunk allegati nel MSG");
         }
     }
 
-    /**
-     * Estrae il nome del file da un allegato MSG.
-     * Prova prima il nome lungo, poi il nome corto come fallback.
-     *
-     * @param attachment L'oggetto AttachmentChunks da cui estrarre il nome
-     * @return Il nome del file, o "attachment" come default
-     */
     private String getAttachmentFileName(AttachmentChunks attachment) {
         try {
             if (attachment.getAttachLongFileName() != null) {
@@ -468,39 +319,22 @@
                 return attachment.getAttachFileName().toString();
             }
         } catch (Exception e) {
-            logger.debug("Errore nel recupero nome allegato: {}", e.getMessage());
+            logger.debug("Errore recupero nome allegato: {}", e.getMessage());
         }
         return "attachment";
     }
 
-    /**
-     * Estrae il MIME type da un allegato MSG.
-     *
-     * @param attachment L'oggetto AttachmentChunks da cui estrarre il MIME type
-     * @return Il MIME type dell'allegato, o null se non disponibile
-     */
     private String getAttachmentMimeType(AttachmentChunks attachment) {
         try {
             if (attachment.getAttachMimeTag() != null) {
                 return attachment.getAttachMimeTag().toString();
             }
         } catch (Exception e) {
-            logger.debug("Errore nel recupero MIME type allegato: {}", e.getMessage());
+            logger.debug("Errore recupero MIME type allegato: {}", e.getMessage());
         }
         return null;
     }
 
-    /**
-     * Salva un'immagine embedded da un allegato MSG.
-     * Crea un file temporaneo con nome sicuro e mappa i vari formati
-     * di Content-ID per i riferimenti HTML.
-     *
-     * @param imageData I dati binari dell'immagine
-     * @param fileName Il nome originale del file allegato
-     * @param mimeType Il MIME type dell'immagine
-     * @param index L'indice dell'allegato per creare nomi univoci
-     * @throws IOException Se si verificano errori durante il salvataggio
-     */
     private void saveEmbeddedImageFromAttachment(byte[] imageData, String fileName, String mimeType, int index) throws IOException {
         String extension = getImageExtension(mimeType);
         String safeFileName = "embedded_" + index + "." + extension;
@@ -510,7 +344,7 @@
             fos.write(imageData);
         }
 
-        // Mappa per riferimenti CID (usa diversi formati possibili)
+        // Mappa riferimenti CID
         String contentId = fileName.replaceAll("[^a-zA-Z0-9._-]", "_");
         embeddedImages.put(contentId, imageFile.getAbsolutePath());
         embeddedImages.put("cid:" + contentId, imageFile.getAbsolutePath());
@@ -519,42 +353,26 @@
         logger.info("Immagine MSG salvata: {} -> {}", fileName, safeFileName);
     }
 
-    /**
-     * Converte contenuto RTF in HTML usando un approccio semplificato.
-     * Rimuove i comandi RTF base e mantiene il testo leggibile,
-     * convertendo i line break in tag HTML appropriati.
-     *
-     * @param rtfBody Il contenuto RTF da convertire
-     * @return L'HTML generato dal contenuto RTF
-     */
     private String convertRtfToHtml(String rtfBody) {
-        // Conversione molto semplice RTF -> HTML
-        // Rimuove i comandi RTF base e mantiene il testo
+        // Conversione semplificata RTF -> HTML
         String text = rtfBody;
 
         // Rimuove header RTF
         text = text.replaceAll("\\{\\\\rtf1[^}]*\\}", "");
 
-        // Rimuove comandi di formattazione RTF
+        // Rimuove comandi RTF
         text = text.replaceAll("\\\\[a-z]+\\d*", "");
         text = text.replaceAll("\\{|\\}", "");
 
         // Pulisce spazi multipli
         text = text.replaceAll("\\s+", " ").trim();
 
-        // Converte newline in <br>
+        // Converte newline
         text = text.replace("\n", "<br>");
 
         return "<div>" + escapeHtml(text) + "</div>";
     }
 
-    /**
-     * Processa i riferimenti CID nell'HTML sostituendoli con percorsi file locali.
-     * Gestisce diversi formati di riferimento CID utilizzati da Outlook.
-     *
-     * @param htmlContent Il contenuto HTML da processare
-     * @return L'HTML con i riferimenti CID sostituiti con percorsi locali
-     */
     private String processCidReferences(String htmlContent) {
         String processed = htmlContent;
 
@@ -562,7 +380,7 @@
             String contentId = entry.getKey();
             String localPath = "file:///" + entry.getValue().replace("\\", "/");
 
-            // Sostituisci vari formati di riferimento
+            // Sostituisci vari formati riferimento
             processed = processed.replaceAll(
                     "src=[\"']cid:" + contentId + "[\"']",
                     "src=\"" + localPath + "\""
@@ -576,36 +394,20 @@
         return processed;
     }
 
-    /**
-     * Converte un tipo MIME in estensione file appropriata per le immagini.
-     *
-     * @param mimeType Il tipo MIME da convertire
-     * @return L'estensione file corrispondente, o "img" come default
-     */
     private String getImageExtension(String mimeType) {
         if (mimeType == null) return "img";
         String lowerType = mimeType.toLowerCase();
-        if ("image/gif".equals(lowerType)) {
-            return "gif";
-        } else if ("image/jpeg".equals(lowerType)) {
-            return "jpg";
-        } else if ("image/png".equals(lowerType)) {
-            return "png";
-        } else if ("image/bmp".equals(lowerType)) {
-            return "bmp";
-        } else if ("image/webp".equals(lowerType)) {
-            return "webp";
-        } else {
-            return "img";
+
+        switch (lowerType) {
+            case "image/gif": return "gif";
+            case "image/jpeg": return "jpg";
+            case "image/png": return "png";
+            case "image/bmp": return "bmp";
+            case "image/webp": return "webp";
+            default: return "img";
         }
     }
 
-    /**
-     * Effettua l'escape dei caratteri HTML speciali per evitare problemi di rendering.
-     *
-     * @param text Il testo da processare
-     * @return Il testo con i caratteri HTML escapati, o stringa vuota se null
-     */
     private String escapeHtml(String text) {
         if (text == null) return "";
         return text.replace("&", "&amp;")
@@ -615,24 +417,18 @@
                 .replace("'", "&#39;");
     }
 
-    @Deprecated
-    /**
-     * Pulisce i file temporanei e la directory di lavoro.
-     * Elimina tutti i file nella directory temporanea e poi la directory stessa.
-     * Viene chiamato nel blocco finally se DEBUG_KEEP_TEMP_FILES è false.
-     */
     private void cleanup() {
         if (tempDir != null && tempDir.exists()) {
             File[] files = tempDir.listFiles();
             if (files != null) {
                 for (File file : files) {
                     if (!file.delete()) {
-                        logger.warn("Impossibile eliminare il file temporaneo: {}", file.getAbsolutePath());
+                        logger.warn("Impossibile eliminare file temporaneo: {}", file.getAbsolutePath());
                     }
                 }
             }
             if (!tempDir.delete()) {
-                logger.warn("Impossibile eliminare la directory temporanea: {}", tempDir.getAbsolutePath());
+                logger.warn("Impossibile eliminare directory temporanea: {}", tempDir.getAbsolutePath());
             }
         }
         embeddedImages.clear();
Index: src/main/java/webService/server/converters/mailConverters/EMLtoPDFconverter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package webService.server.converters.mailConverters;\n\nimport webService.server.configuration.configHandlers.conversionContext.ConversionContextReader;\nimport webService.server.configuration.configHandlers.serverConfig.ConfigReader;\nimport webService.server.converters.Converter;\nimport org.apache.james.mime4j.dom.*;\nimport org.apache.james.mime4j.dom.field.ContentTypeField;\nimport org.apache.james.mime4j.message.DefaultMessageBuilder;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport webService.server.converters.PDFWatermarkApplier;\nimport webService.server.converters.exception.WatermarkException;\n\nimport java.awt.Desktop;\nimport java.io.*;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Convertitore EML to PDF usando Chrome/Chromium headless nativo.\n * Implementa l'approccio: EML → HTML → PDF tramite Chrome --headless.\n * Supporta immagini embedded, diversi encoding e gestisce automaticamente\n * la pulizia dei file temporanei.\n */\npublic class EMLtoPDFconverter extends Converter {\n\n    private static final Logger logger = LogManager.getLogger(EMLtoPDFconverter.class);\n    private Map<String, String> embeddedImages = new HashMap<String, String>();\n    private File tempDir;\n    private String originalBaseName; // Campo per memorizzare il nome base originale del file EML\n\n    private static final boolean DEBUG_OPEN_HTML_IN_BROWSER = false;\n    private static final boolean DEBUG_KEEP_TEMP_FILES = true; // Mantenuto TRUE per debugging\n\n    /**\n     * Converte un file EML in PDF utilizzando Chrome Headless.\n     * Il processo include parsing dell'email, estrazione immagini embedded,\n     * generazione HTML e conversione finale in PDF.\n     *\n     * @param emlFile Il file EML da convertire\n     * @return Il file PDF generato\n     * @throws IOException Se si verificano errori durante la conversione\n     */\n    @Override\n    public File convert(File emlFile) throws IOException, WatermarkException {\n        if (emlFile == null || !emlFile.exists()) {\n            throw new FileNotFoundException(\"File EML non trovato: \" + emlFile);\n        }\n\n        logger.info(\"Inizio conversione EML to PDF con Chrome Headless: {}\", emlFile.getName());\n\n        tempDir = new File(emlFile.getParent());\n\n        try {\n            Message message = parseEmailMessage(emlFile);\n            extractEmbeddedImages(message.getBody());\n            File htmlFile = generateCompleteHtml(message);\n\n            File pdfFile = convertHtmlToPdfWithChrome(htmlFile);\n\n            logger.info(\"Conversione completata: {}\", pdfFile.getName());\n\n            if (!ConversionContextReader.getWatermark().isEmpty()) {\n                logger.info(\"Applying watermark to PDF...\");\n\n                // Crea un file temporaneo per il PDF con watermark nella stessa directory\n                File tempFile = new File(pdfFile.getParent(), \"watermarked_\" + pdfFile.getName());\n\n                logger.info(\"Original file: {}\", pdfFile.getAbsolutePath());\n                logger.info(\"Temp file for watermark: {}\", tempFile.getAbsolutePath());\n\n                try {\n                    boolean success = PDFWatermarkApplier.applyWatermark(\n                            pdfFile,\n                            tempFile,\n                            ConversionContextReader.getWatermark()\n                    );\n\n                    logger.info(\"Watermark application completed, success: {}\", success);\n\n                    if (success && tempFile.exists() && tempFile.length() > 0) {\n                        logger.info(\"Watermark applied successfully, replacing original file\");\n\n                        // Usa Files.move() per sostituzione atomica\n                        try {\n                            Files.move(tempFile.toPath(), pdfFile.toPath(),\n                                    StandardCopyOption.REPLACE_EXISTING);\n                            logger.info(\"File watermarkato sostituito correttamente\");\n                            //logger.info(\"tempfile: {}, pdffile: {}\", tempFile.);\n\n                            return pdfFile; // Ritorna sempre pdfFile\n                        } catch (IOException e) {\n                            logger.warn(\"Impossibile sostituire il file: {}\", e.getMessage());\n                            throw new WatermarkException(\"Impossibile sostituire il file con watermark: \" + e.getMessage());\n                        }\n                    } else {\n                        logger.warn(\"Watermark application failed - temp file not created or empty\");\n                        throw new WatermarkException(\"Watermark non applicato correttamente\");\n                    }\n                } catch (Exception e) {\n                    throw new WatermarkException(\"Impossibile applicare il watermark: \" + e.getMessage());\n                }\n            }\n\n            return pdfFile;\n\n        } catch (Exception e) {\n            logger.error(\"Errore durante la conversione\", e);\n            throw new IOException(\"Errore durante la conversione: \" + e.getMessage(), e);\n        }\n//        finally {\n//            if (!DEBUG_KEEP_TEMP_FILES) {\n//                cleanup();\n//                logger.info(\"File temporanei eliminati.\");\n//            } else {\n//                logger.info(\"File temporanei mantenuti per debugging nella directory: {}\", tempDir.getAbsolutePath());\n//            }\n//        }\n    }\n\n\n    /**\n     * Effettua il parsing del file EML utilizzando Apache James Mime4J.\n     *\n     * @param emlFile Il file EML da analizzare\n     * @return L'oggetto Message contenente i dati parsati dell'email\n     * @throws IOException Se si verificano errori durante il parsing\n     */\n    private Message parseEmailMessage(File emlFile) throws IOException {\n        DefaultMessageBuilder builder = new DefaultMessageBuilder();\n        try (InputStream is = Files.newInputStream(emlFile.toPath())) {\n            return builder.parseMessage(is);\n        }\n    }\n\n    /**\n     * Converte il file HTML in PDF utilizzando Chrome Headless.\n     * Configura tutti i parametri necessari per una conversione di qualità\n     * e gestisce l'esecuzione del processo Chrome.\n     *\n     * @param htmlFile Il file HTML da convertire\n     * @return Il file PDF generato\n     * @throws IOException Se Chrome non è disponibile o la conversione fallisce\n     * @throws InterruptedException Se il processo viene interrotto\n     */\n    private File convertHtmlToPdfWithChrome(File htmlFile) throws IOException, InterruptedException {\n        String chromePath = ChromeManager.getInstance().getChromePath();\n        if (chromePath == null) {\n            throw new IOException(\"Chrome non disponibile tramite ChromeManager\");\n        }\n\n        // Usa il nome base originale (del file EML) per il nome del file PDF\n        File pdfFile = new File(tempDir, originalBaseName + \".pdf\");\n\n        List<String> command = new ArrayList<String>();\n        command.add(chromePath);\n        command.add(\"--headless\");\n        command.add(\"--no-sandbox\"); // Necessario in alcuni ambienti Linux/Docker\n        command.add(\"--disable-gpu\"); // Necessario per ambienti senza GUI/GPU\n        command.add(\"--disable-dev-shm-usage\"); // Utile in ambienti Docker/Linux\n        command.add(\"--disable-extensions\");\n        command.add(\"--disable-plugins\");\n        command.add(\"--run-all-compositor-stages-before-draw\"); // Garantisce rendering completo\n        command.add(\"--virtual-time-budget=10000\"); // 10 secondi timeout caricamento pagina\n        command.add(\"--print-to-pdf=\" + pdfFile.getAbsolutePath());\n        command.add(\"--print-to-pdf-no-header\"); // Flag per rimuovere header/footer predefiniti del browser\n        command.add(\"file://\" + htmlFile.getAbsolutePath().replace(\"\\\\\", \"/\")); // Percorso del file HTML da convertire\n\n        logger.info(\"Esecuzione comando Chrome: {}\", String.join(\" \", command));\n\n        ProcessBuilder pb = new ProcessBuilder(command);\n        pb.redirectErrorStream(true);\n\n        Process process = pb.start();\n\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String line;\n            StringBuilder output = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            if (output.length() > 0) {\n                logger.debug(\"Output Chrome: {}\", output.toString());\n            }\n        }\n\n        int exitCode = process.waitFor();\n\n        if (exitCode != 0) {\n            logger.error(\"Chrome headless failed with exit code: {}. Command: {}\", exitCode, String.join(\" \", command));\n            throw new IOException(\"Chrome headless failed with exit code: \" + exitCode);\n        }\n\n        if (!pdfFile.exists()) {\n            logger.error(\"PDF non generato da Chrome. Percorso atteso: {}\", pdfFile.getAbsolutePath());\n            throw new IOException(\"PDF non generato da Chrome\");\n        }\n\n        return pdfFile;\n    }\n\n    /**\n     * Apre il file HTML generato nel browser per debug e verifica visuale.\n     * Prova prima il browser predefinito del sistema, poi Chrome esplicito.\n     * Questo metodo è chiamato solo se DEBUG_OPEN_HTML_IN_BROWSER è true.\n     *\n     * @param htmlFile Il file HTML da aprire\n     * @param chromePath Il percorso di Chrome da usare come fallback\n     */\n    private void openHtmlInBrowser(File htmlFile, String chromePath) {\n        if (!htmlFile.exists()) {\n            logger.warn(\"Impossibile aprire il file HTML, non esiste: {}\", htmlFile.getAbsolutePath());\n            return;\n        }\n\n        try {\n            if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {\n                Desktop.getDesktop().browse(htmlFile.toURI());\n                logger.info(\"File HTML aperto con il browser predefinito: {}\", htmlFile.getAbsolutePath());\n                return;\n            }\n        } catch (UnsupportedOperationException e) {\n            logger.warn(\"L'operazione 'browse' non è supportata dal Desktop API in questo ambiente. Errore: {}\", e.getMessage());\n        } catch (IOException e) {\n            logger.warn(\"Errore I/O durante l'apertura del file HTML con il browser predefinito: {}\", e.getMessage());\n        }\n\n        if (chromePath != null && new File(chromePath).exists()) {\n            try {\n                List<String> command = new ArrayList<>();\n                command.add(chromePath);\n                command.add(htmlFile.toURI().toString());\n\n                logger.info(\"Tentativo di apertura HTML con Chrome esplicito: {}\", String.join(\" \", command));\n\n                ProcessBuilder pb = new ProcessBuilder(command);\n                pb.redirectErrorStream(true);\n                Process process = pb.start();\n                logger.info(\"Comando di apertura Chrome avviato per: {}\", htmlFile.getAbsolutePath());\n\n            } catch (IOException e) {\n                logger.error(\"Errore durante il tentativo di aprire l'HTML con Chrome esplicito: {}\", e.getMessage());\n            }\n        } else {\n            logger.warn(\"Impossibile aprire l'HTML nel browser: Desktop API non disponibile e percorso Chrome non valido.\");\n        }\n    }\n\n    /**\n     * Genera il file HTML completo dall'email parsata.\n     * Include CSS ottimizzato per stampa, gestione responsive e\n     * il contenuto dell'email processato per la conversione PDF.\n     *\n     * @param message L'oggetto Message contenente i dati dell'email\n     * @return Il file HTML generato e pronto per la conversione\n     * @throws IOException Se si verificano errori durante la generazione\n     */\n    private File generateCompleteHtml(Message message) throws IOException {\n        StringBuilder html = new StringBuilder();\n\n        // Header HTML standard\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html>\\n\");\n        html.append(\"<head>\\n\");\n        html.append(\"    <meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\">\\n\");\n        html.append(\"    <title>Email PDF</title>\\n\");\n        html.append(\"    <style>\\n\");\n        html.append(\"        @page {\\n\");\n        html.append(\"            size: A4;\\n\");\n        html.append(\"            margin: 0; /* Imposta i margini della pagina di stampa a 0 per eliminare spazi vuoti */\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        html, body {\\n\");\n        html.append(\"            margin: 0;\\n\");\n        html.append(\"            padding: 0;\\n\");\n        html.append(\"            height: 100%;\\n\"); // Assicura che html e body coprano l'intera altezza\n        html.append(\"            width: 100%;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        * {\\n\");\n        html.append(\"            box-sizing: border-box;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        body {\\n\");\n        html.append(\"            font-family: 'Segoe UI', Arial, sans-serif;\\n\");\n        html.append(\"            font-size: 11px;\\n\");\n        html.append(\"            line-height: 1.4;\\n\");\n        html.append(\"            color: #333;\\n\");\n        html.append(\"            background: white;\\n\");\n        html.append(\"        }\\n\");\n\n        html.append(\"        .email-content {\\n\");\n        html.append(\"            max-width: 100%;\\n\");\n        html.append(\"            word-wrap: break-word;\\n\");\n        html.append(\"            overflow-wrap: break-word;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        img {\\n\");\n        html.append(\"            max-width: 100%;\\n\");\n        html.append(\"            height: auto;\\n\");\n        html.append(\"            display: block;\\n\");\n        html.append(\"            margin: 8px 0;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        table {\\n\");\n        html.append(\"            border-collapse: collapse;\\n\");\n        html.append(\"            width: 100%;\\n\");\n        html.append(\"            margin: 8px 0;\\n\");\n        html.append(\"            font-size: inherit;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        td, th {\\n\");\n        html.append(\"            padding: 6px;\\n\");\n        html.append(\"            vertical-align: top;\\n\");\n        html.append(\"            border: 1px solid #ddd;\\n\");\n        html.append(\"            word-wrap: break-word;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        .no-print {\\n\");\n        html.append(\"            display: none !important;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        table table {\\n\");\n        html.append(\"            border: none;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        html.append(\"        table table td {\\n\");\n        html.append(\"            border: none;\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"        \\n\");\n        // NUOVE REGOLE CSS per nascondere i footer/header di stampa di Chrome\n        html.append(\"        @media print {\\n\");\n        html.append(\"            /* Nasconde gli header/footer testuali di Chrome */\\n\");\n        html.append(\"            body::before, body::after {\\n\");\n        html.append(\"                content: none !important;\\n\");\n        html.append(\"                display: none !important;\\n\");\n        html.append(\"            }\\n\");\n        html.append(\"            /* Forza i margini della pagina a zero per evitare spazi bianchi indesiderati */\\n\");\n        html.append(\"            @page {\\n\");\n        html.append(\"                margin: 0 !important;\\n\");\n        html.append(\"            }\\n\");\n        html.append(\"        }\\n\");\n        html.append(\"    </style>\\n\");\n        html.append(\"</head>\\n\");\n        html.append(\"<body>\\n\");\n\n        html.append(\"<div class=\\\"email-content\\\">\");\n        appendEmailContent(html, message.getBody());\n        html.append(\"</div>\");\n\n        html.append(\"</body></html>\");\n\n        File htmlFile = new File(tempDir, \"email.html\");\n        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(htmlFile), StandardCharsets.UTF_8)) {\n            writer.write(html.toString());\n        }\n\n        logger.info(\"HTML generato: {}\", htmlFile.getAbsolutePath());\n        return htmlFile;\n    }\n\n    /**\n     * Aggiunge gli header dell'email (Da, A, Oggetto, Data) all'HTML.\n     * Metodo helper per formattare le informazioni di intestazione dell'email.\n     *\n     * @param html Il StringBuilder dove aggiungere l'HTML degli header\n     * @param message L'oggetto Message contenente i dati dell'email\n     */\n    private void appendEmailHeaders(StringBuilder html, Message message) {\n        appendHeaderField(html, \"Da:\", getFieldValue(message.getFrom()));\n        appendHeaderField(html, \"A:\", getFieldValue(message.getTo()));\n        if (message.getCc() != null) {\n            appendHeaderField(html, \"Cc:\", getFieldValue(message.getCc()));\n        }\n        appendHeaderField(html, \"Oggetto:\", message.getSubject());\n        appendHeaderField(html, \"Data:\", getFieldValue(message.getDate()));\n    }\n\n    /**\n     * Aggiunge un singolo campo di header formattato all'HTML.\n     *\n     * @param html Il StringBuilder dove aggiungere l'HTML\n     * @param label L'etichetta del campo (es. \"Da:\", \"A:\")\n     * @param value Il valore del campo\n     */\n    private void appendHeaderField(StringBuilder html, String label, String value) {\n        html.append(\"<div class=\\\"header-field\\\">\")\n                .append(\"<span class=\\\"header-label\\\">\").append(escapeHtml(label)).append(\"</span>\")\n                .append(\"<span>\").append(escapeHtml(value != null ? value : \"\")).append(\"</span>\")\n                .append(\"</div>\");\n    }\n\n    /**\n     * Processa ricorsivamente il contenuto dell'email e lo converte in HTML.\n     * Gestisce sia parti testuali (HTML/plain text) che multipart,\n     * processando le immagini embedded e i riferimenti CID.\n     *\n     * @param html Il StringBuilder dove aggiungere l'HTML del contenuto\n     * @param body Il Body dell'email da processare\n     * @throws IOException Se si verificano errori durante la lettura del contenuto\n     */\n    private void appendEmailContent(StringBuilder html, Body body) throws IOException {\n        if (body instanceof TextBody) {\n            TextBody textBody = (TextBody) body;\n            String mimeType = getContentType(textBody);\n            String content = readTextContent(textBody);\n\n            if (mimeType.contains(\"text/html\")) {\n                String processedHtml = processCidReferences(content);\n                html.append(processedHtml);\n            } else if (mimeType.contains(\"text/plain\")) {\n                // Non generiamo alcun HTML per il contenuto text/plain\n                // se non desiderato (come da tua precedente indicazione).\n            }\n        } else if (body instanceof Multipart) {\n            Multipart multipart = (Multipart) body;\n            for (Entity part : multipart.getBodyParts()) {\n                appendEmailContent(html, part.getBody());\n            }\n        }\n    }\n\n    /**\n     * Estrae ricorsivamente le immagini embedded dall'email.\n     * Cerca parti con MIME type image/* e Content-ID, salvandole come file temporanei\n     * per il riferimento nell'HTML generato.\n     *\n     * @param body Il Body dell'email da analizzare\n     * @throws IOException Se si verificano errori durante l'estrazione\n     */\n    private void extractEmbeddedImages(Body body) throws IOException {\n        if (body instanceof TextBody) {\n            TextBody textBody = (TextBody) body;\n            String mimeType = getContentType(textBody);\n\n            if (mimeType.startsWith(\"image/\")) {\n                String contentId = getContentId(textBody);\n                if (contentId != null) {\n                    saveEmbeddedImage(textBody, contentId, mimeType);\n                }\n            }\n        } else if (body instanceof Multipart) {\n            Multipart multipart = (Multipart) body;\n            for (Entity part : multipart.getBodyParts()) {\n                extractEmbeddedImages(part.getBody());\n            }\n        }\n    }\n\n    /**\n     * Salva un'immagine embedded decodificando il contenuto Base64.\n     * Crea un file temporaneo e mappa il Content-ID per i riferimenti HTML.\n     *\n     * @param textBody Il TextBody contenente i dati dell'immagine\n     * @param contentId Il Content-ID dell'immagine per i riferimenti CID\n     * @param mimeType Il tipo MIME dell'immagine\n     * @throws IOException Se si verificano errori durante il salvataggio\n     */\n    private void saveEmbeddedImage(TextBody textBody, String contentId, String mimeType) throws IOException {\n        String content = readTextContent(textBody);\n\n        try {\n            byte[] imageData = java.util.Base64.getDecoder().decode(content.replaceAll(\"\\\\s\", \"\"));\n            String extension = getImageExtension(mimeType);\n            String fileName = contentId.replaceAll(\"[<>]\", \"\") + \".\" + extension;\n\n            File imageFile = new File(tempDir, fileName);\n            try (FileOutputStream fos = new FileOutputStream(imageFile)) {\n                fos.write(imageData);\n            }\n\n            embeddedImages.put(contentId, imageFile.getAbsolutePath());\n            logger.info(\"Immagine salvata: {} -> {}\", contentId, fileName);\n\n        } catch (IllegalArgumentException e) {\n            logger.warn(\"Impossibile decodificare immagine Base64: {}\", contentId);\n        }\n    }\n\n    /**\n     * Processa i riferimenti CID nell'HTML sostituendoli con percorsi file locali.\n     * Converte i riferimenti \"cid:contentId\" in percorsi \"file:///\" per Chrome.\n     *\n     * @param htmlContent Il contenuto HTML da processare\n     * @return L'HTML con i riferimenti CID sostituiti\n     */\n    private String processCidReferences(String htmlContent) {\n        String processed = htmlContent;\n\n        for (Map.Entry<String, String> entry : embeddedImages.entrySet()) {\n            String contentId = entry.getKey().replaceAll(\"[<>]\", \"\");\n            String localPath = \"file:///\" + entry.getValue().replace(\"\\\\\", \"/\");\n            processed = processed.replaceAll(\n                    \"src=[\\\"']cid:\" + contentId + \"[\\\"']\",\n                    \"src=\\\"\" + localPath + \"\\\"\"\n            );\n        }\n\n        return processed;\n    }\n\n    /**\n     * Estrae il Content-Type dal TextBody analizzando gli header della parte.\n     *\n     * @param textBody Il TextBody da analizzare\n     * @return Il tipo MIME, o \"text/plain\" come default\n     */\n    private String getContentType(TextBody textBody) {\n        Entity parent = textBody.getParent();\n        if (parent != null && parent.getHeader() != null) {\n            ContentTypeField field = (ContentTypeField) parent.getHeader().getField(\"Content-Type\");\n            return field != null ? field.getMimeType() : \"text/plain\";\n        }\n        return \"text/plain\";\n    }\n\n    /**\n     * Estrae il Content-ID dal TextBody analizzando gli header della parte.\n     *\n     * @param textBody Il TextBody da analizzare\n     * @return Il Content-ID, o null se non presente\n     */\n    private String getContentId(TextBody textBody) {\n        Entity parent = textBody.getParent();\n        if (parent != null && parent.getHeader() != null) {\n            org.apache.james.mime4j.stream.Field field = parent.getHeader().getField(\"Content-ID\");\n            return field != null ? field.getBody() : null;\n        }\n        return null;\n    }\n\n    /**\n     * Legge il contenuto testuale di un TextBody rilevando automaticamente l'encoding\n     * dall'header Content-Type. Supporta fallback intelligente per encoding non supportati.\n     *\n     * @param textBody Il TextBody da leggere\n     * @return Il contenuto testuale decodificato correttamente\n     * @throws IOException Se si verificano errori durante la lettura\n     */\n    private String readTextContent(TextBody textBody) throws IOException {\n        String charset = getCharset(textBody);\n\n        // Prima prova con il charset rilevato\n        try (InputStreamReader reader = new InputStreamReader(textBody.getInputStream(), charset)) {\n            return readFromReader(reader);\n        } catch (UnsupportedEncodingException e) {\n            logger.warn(\"Charset non supportato: {}, tentativo fallback su UTF-8\", charset);\n\n            // Fallback 1: UTF-8\n            try (InputStreamReader reader = new InputStreamReader(textBody.getInputStream(), StandardCharsets.UTF_8)) {\n                return readFromReader(reader);\n            } catch (Exception e2) {\n                logger.warn(\"Fallback UTF-8 fallito, tentativo con ISO-8859-1\");\n\n                // Fallback 2: ISO-8859-1 (supporta tutti i byte 0-255)\n                try (InputStreamReader reader = new InputStreamReader(textBody.getInputStream(), StandardCharsets.ISO_8859_1)) {\n                    return readFromReader(reader);\n                } catch (Exception e3) {\n                    logger.error(\"Tutti i tentativi di decodifica falliti, uso default system charset\");\n\n                    // Fallback finale: charset di sistema\n                    try (InputStreamReader reader = new InputStreamReader(textBody.getInputStream())) {\n                        return readFromReader(reader);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Rileva il charset dall'header Content-Type del TextBody.\n     *\n     * @param textBody Il TextBody da analizzare\n     * @return Il charset rilevato o \"UTF-8\" come default\n     */\n    private String getCharset(TextBody textBody) {\n        Entity parent = textBody.getParent();\n        if (parent != null && parent.getHeader() != null) {\n            ContentTypeField field = (ContentTypeField) parent.getHeader().getField(\"Content-Type\");\n            if (field != null && field.getCharset() != null) {\n                String charset = field.getCharset();\n                logger.debug(\"Charset rilevato dall'header: {}\", charset);\n                return charset;\n            }\n        }\n\n        // Default fallback\n        logger.debug(\"Nessun charset specificato, uso UTF-8 come default\");\n        return \"UTF-8\";\n    }\n\n    /**\n     * Utility method per leggere da un InputStreamReader.\n     *\n     * @param reader Il reader da cui leggere\n     * @return Il contenuto letto come stringa\n     * @throws IOException Se si verificano errori durante la lettura\n     */\n    private String readFromReader(InputStreamReader reader) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        char[] buffer = new char[4096];\n        int bytesRead;\n        while ((bytesRead = reader.read(buffer)) != -1) {\n            sb.append(buffer, 0, bytesRead);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Converte un tipo MIME in estensione file appropriata.\n     *\n     * @param mimeType Il tipo MIME da convertire\n     * @return L'estensione file corrispondente\n     */\n    private String getImageExtension(String mimeType) {\n        String lowerType = mimeType.toLowerCase();\n        if (\"image/gif\".equals(lowerType)) {\n            return \"gif\";\n        } else if (\"image/jpeg\".equals(lowerType)) {\n            return \"jpg\";\n        } else if (\"image/png\".equals(lowerType)) {\n            return \"png\";\n        } else if (\"image/bmp\".equals(lowerType)) {\n            return \"bmp\";\n        } else if (\"image/webp\".equals(lowerType)) {\n            return \"webp\";\n        } else {\n            return \"img\";\n        }\n    }\n\n    /**\n     * Converte un oggetto field in stringa per la visualizzazione.\n     *\n     * @param field L'oggetto field da convertire\n     * @return La rappresentazione stringa del field, o stringa vuota se null\n     */\n    private String getFieldValue(Object field) {\n        return field != null ? field.toString() : \"\";\n    }\n\n    /**\n     * Effettua l'escape dei caratteri HTML speciali per evitare problemi di rendering.\n     *\n     * @param text Il testo da processare\n     * @return Il testo con i caratteri HTML escapati\n     */\n    private String escapeHtml(String text) {\n        if (text == null) return \"\";\n        return text.replace(\"&\", \"&amp;\")\n                .replace(\"<\", \"&lt;\")\n                .replace(\">\", \"&gt;\")\n                .replace(\"\\\"\", \"&quot;\")\n                .replace(\"'\", \"&#39;\");\n    }\n\n    @Deprecated\n    /**\n     * Pulisce i file temporanei e la directory di lavoro.\n     * Elimina tutti i file nella directory temporanea e poi la directory stessa.\n     * Viene chiamato nel blocco finally se DEBUG_KEEP_TEMP_FILES è false.\n     */\n    private void cleanup() {\n        if (tempDir != null && tempDir.exists()) {\n            File[] files = tempDir.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    if (!file.delete()) {\n                        logger.warn(\"Impossibile eliminare il file temporaneo: {}\", file.getAbsolutePath());\n                    }\n                }\n            }\n            if (!tempDir.delete()) {\n                logger.warn(\"Impossibile eliminare la directory temporanea: {}\", tempDir.getAbsolutePath());\n            }\n        }\n        embeddedImages.clear();\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/webService/server/converters/mailConverters/EMLtoPDFconverter.java b/src/main/java/webService/server/converters/mailConverters/EMLtoPDFconverter.java
--- a/src/main/java/webService/server/converters/mailConverters/EMLtoPDFconverter.java	(revision c03fcda81ec80ee23b4f0e9aa9b8f8e2a00cc447)
+++ b/src/main/java/webService/server/converters/mailConverters/EMLtoPDFconverter.java	(date 1751446061460)
@@ -1,7 +1,6 @@
 package webService.server.converters.mailConverters;
 
 import webService.server.configuration.configHandlers.conversionContext.ConversionContextReader;
-import webService.server.configuration.configHandlers.serverConfig.ConfigReader;
 import webService.server.converters.Converter;
 import org.apache.james.mime4j.dom.*;
 import org.apache.james.mime4j.dom.field.ContentTypeField;
@@ -11,52 +10,36 @@
 import webService.server.converters.PDFWatermarkApplier;
 import webService.server.converters.exception.WatermarkException;
 
-import java.awt.Desktop;
 import java.io.*;
-import java.net.URI;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
-import java.nio.file.Path;
 import java.nio.file.StandardCopyOption;
-import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
 /**
- * Convertitore EML to PDF usando Chrome/Chromium headless nativo.
- * Implementa l'approccio: EML → HTML → PDF tramite Chrome --headless.
- * Supporta immagini embedded, diversi encoding e gestisce automaticamente
- * la pulizia dei file temporanei.
+ * Convertitore EML to PDF usando Chrome Headless nel container Docker.
+ * Ottimizzato per il setup Docker con Chrome for Testing.
  */
 public class EMLtoPDFconverter extends Converter {
 
     private static final Logger logger = LogManager.getLogger(EMLtoPDFconverter.class);
-    private Map<String, String> embeddedImages = new HashMap<String, String>();
+    private Map<String, String> embeddedImages = new HashMap<>();
     private File tempDir;
-    private String originalBaseName; // Campo per memorizzare il nome base originale del file EML
+    private String originalBaseName;
 
-    private static final boolean DEBUG_OPEN_HTML_IN_BROWSER = false;
-    private static final boolean DEBUG_KEEP_TEMP_FILES = true; // Mantenuto TRUE per debugging
+    private static final boolean DEBUG_KEEP_TEMP_FILES = true; // Per debugging
 
-    /**
-     * Converte un file EML in PDF utilizzando Chrome Headless.
-     * Il processo include parsing dell'email, estrazione immagini embedded,
-     * generazione HTML e conversione finale in PDF.
-     *
-     * @param emlFile Il file EML da convertire
-     * @return Il file PDF generato
-     * @throws IOException Se si verificano errori durante la conversione
-     */
     @Override
     public File convert(File emlFile) throws IOException, WatermarkException {
         if (emlFile == null || !emlFile.exists()) {
             throw new FileNotFoundException("File EML non trovato: " + emlFile);
         }
 
-        logger.info("Inizio conversione EML to PDF con Chrome Headless: {}", emlFile.getName());
+        logger.info("Inizio conversione EML to PDF: {}", emlFile.getName());
 
         tempDir = new File(emlFile.getParent());
+        originalBaseName = emlFile.getName().replaceAll("\\.[^.]*$", "");
 
         try {
             Message message = parseEmailMessage(emlFile);
@@ -67,72 +50,14 @@
 
             logger.info("Conversione completata: {}", pdfFile.getName());
 
-            if (!ConversionContextReader.getWatermark().isEmpty()) {
-                logger.info("Applying watermark to PDF...");
-
-                // Crea un file temporaneo per il PDF con watermark nella stessa directory
-                File tempFile = new File(pdfFile.getParent(), "watermarked_" + pdfFile.getName());
-
-                logger.info("Original file: {}", pdfFile.getAbsolutePath());
-                logger.info("Temp file for watermark: {}", tempFile.getAbsolutePath());
-
-                try {
-                    boolean success = PDFWatermarkApplier.applyWatermark(
-                            pdfFile,
-                            tempFile,
-                            ConversionContextReader.getWatermark()
-                    );
-
-                    logger.info("Watermark application completed, success: {}", success);
-
-                    if (success && tempFile.exists() && tempFile.length() > 0) {
-                        logger.info("Watermark applied successfully, replacing original file");
-
-                        // Usa Files.move() per sostituzione atomica
-                        try {
-                            Files.move(tempFile.toPath(), pdfFile.toPath(),
-                                    StandardCopyOption.REPLACE_EXISTING);
-                            logger.info("File watermarkato sostituito correttamente");
-                            //logger.info("tempfile: {}, pdffile: {}", tempFile.);
-
-                            return pdfFile; // Ritorna sempre pdfFile
-                        } catch (IOException e) {
-                            logger.warn("Impossibile sostituire il file: {}", e.getMessage());
-                            throw new WatermarkException("Impossibile sostituire il file con watermark: " + e.getMessage());
-                        }
-                    } else {
-                        logger.warn("Watermark application failed - temp file not created or empty");
-                        throw new WatermarkException("Watermark non applicato correttamente");
-                    }
-                } catch (Exception e) {
-                    throw new WatermarkException("Impossibile applicare il watermark: " + e.getMessage());
-                }
-            }
-
             return pdfFile;
 
         } catch (Exception e) {
-            logger.error("Errore durante la conversione", e);
-            throw new IOException("Errore durante la conversione: " + e.getMessage(), e);
+            logger.error("Errore durante conversione EML", e);
+            throw new IOException("Errore durante conversione: " + e.getMessage(), e);
         }
-//        finally {
-//            if (!DEBUG_KEEP_TEMP_FILES) {
-//                cleanup();
-//                logger.info("File temporanei eliminati.");
-//            } else {
-//                logger.info("File temporanei mantenuti per debugging nella directory: {}", tempDir.getAbsolutePath());
-//            }
-//        }
     }
 
-
-    /**
-     * Effettua il parsing del file EML utilizzando Apache James Mime4J.
-     *
-     * @param emlFile Il file EML da analizzare
-     * @return L'oggetto Message contenente i dati parsati dell'email
-     * @throws IOException Se si verificano errori durante il parsing
-     */
     private Message parseEmailMessage(File emlFile) throws IOException {
         DefaultMessageBuilder builder = new DefaultMessageBuilder();
         try (InputStream is = Files.newInputStream(emlFile.toPath())) {
@@ -140,132 +65,62 @@
         }
     }
 
-    /**
-     * Converte il file HTML in PDF utilizzando Chrome Headless.
-     * Configura tutti i parametri necessari per una conversione di qualità
-     * e gestisce l'esecuzione del processo Chrome.
-     *
-     * @param htmlFile Il file HTML da convertire
-     * @return Il file PDF generato
-     * @throws IOException Se Chrome non è disponibile o la conversione fallisce
-     * @throws InterruptedException Se il processo viene interrotto
-     */
     private File convertHtmlToPdfWithChrome(File htmlFile) throws IOException, InterruptedException {
-        String chromePath = ChromeManager.getInstance().getChromePath();
-        if (chromePath == null) {
-            throw new IOException("Chrome non disponibile tramite ChromeManager");
+        ChromeManager chromeManager = ChromeManager.getInstance();
+        if (!chromeManager.isChromeAvailable()) {
+            throw new IOException("Chrome non disponibile nel container");
         }
 
-        // Usa il nome base originale (del file EML) per il nome del file PDF
         File pdfFile = new File(tempDir, originalBaseName + ".pdf");
 
-        List<String> command = new ArrayList<String>();
-        command.add(chromePath);
-        command.add("--headless");
-        command.add("--no-sandbox"); // Necessario in alcuni ambienti Linux/Docker
-        command.add("--disable-gpu"); // Necessario per ambienti senza GUI/GPU
-        command.add("--disable-dev-shm-usage"); // Utile in ambienti Docker/Linux
-        command.add("--disable-extensions");
-        command.add("--disable-plugins");
-        command.add("--run-all-compositor-stages-before-draw"); // Garantisce rendering completo
-        command.add("--virtual-time-budget=10000"); // 10 secondi timeout caricamento pagina
-        command.add("--print-to-pdf=" + pdfFile.getAbsolutePath());
-        command.add("--print-to-pdf-no-header"); // Flag per rimuovere header/footer predefiniti del browser
-        command.add("file://" + htmlFile.getAbsolutePath().replace("\\", "/")); // Percorso del file HTML da convertire
-
-        logger.info("Esecuzione comando Chrome: {}", String.join(" ", command));
+        try {
+            // Usa ChromeManager per creare il processo ottimizzato
+            ProcessBuilder pb = chromeManager.createChromeProcess(
+                    "--print-to-pdf=" + pdfFile.getAbsolutePath(),
+                    "--print-to-pdf-no-header",
+                    "file://" + htmlFile.getAbsolutePath().replace("\\", "/")
+            );
 
-        ProcessBuilder pb = new ProcessBuilder(command);
-        pb.redirectErrorStream(true);
-
-        Process process = pb.start();
+            logger.info("Avvio Chrome per conversione PDF...");
+            Process process = pb.start();
 
-        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
-            String line;
-            StringBuilder output = new StringBuilder();
-            while ((line = reader.readLine()) != null) {
-                output.append(line).append("\n");
-            }
-            if (output.length() > 0) {
-                logger.debug("Output Chrome: {}", output.toString());
-            }
-        }
+            // Log output Chrome
+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
+                String line;
+                StringBuilder output = new StringBuilder();
+                while ((line = reader.readLine()) != null) {
+                    output.append(line).append("\n");
+                }
+                if (output.length() > 0) {
+                    logger.debug("Chrome output: {}", output.toString());
+                }
+            }
 
-        int exitCode = process.waitFor();
+            int exitCode = process.waitFor();
 
-        if (exitCode != 0) {
-            logger.error("Chrome headless failed with exit code: {}. Command: {}", exitCode, String.join(" ", command));
-            throw new IOException("Chrome headless failed with exit code: " + exitCode);
-        }
+            if (exitCode != 0) {
+                logger.error("Chrome failed with exit code: {}", exitCode);
+                throw new IOException("Chrome conversion failed with exit code: " + exitCode);
+            }
 
-        if (!pdfFile.exists()) {
-            logger.error("PDF non generato da Chrome. Percorso atteso: {}", pdfFile.getAbsolutePath());
-            throw new IOException("PDF non generato da Chrome");
-        }
+            if (!pdfFile.exists()) {
+                logger.error("PDF non generato. Path: {}", pdfFile.getAbsolutePath());
+                throw new IOException("PDF file not generated by Chrome");
+            }
 
-        return pdfFile;
-    }
-
-    /**
-     * Apre il file HTML generato nel browser per debug e verifica visuale.
-     * Prova prima il browser predefinito del sistema, poi Chrome esplicito.
-     * Questo metodo è chiamato solo se DEBUG_OPEN_HTML_IN_BROWSER è true.
-     *
-     * @param htmlFile Il file HTML da aprire
-     * @param chromePath Il percorso di Chrome da usare come fallback
-     */
-    private void openHtmlInBrowser(File htmlFile, String chromePath) {
-        if (!htmlFile.exists()) {
-            logger.warn("Impossibile aprire il file HTML, non esiste: {}", htmlFile.getAbsolutePath());
-            return;
-        }
-
-        try {
-            if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
-                Desktop.getDesktop().browse(htmlFile.toURI());
-                logger.info("File HTML aperto con il browser predefinito: {}", htmlFile.getAbsolutePath());
-                return;
-            }
-        } catch (UnsupportedOperationException e) {
-            logger.warn("L'operazione 'browse' non è supportata dal Desktop API in questo ambiente. Errore: {}", e.getMessage());
-        } catch (IOException e) {
-            logger.warn("Errore I/O durante l'apertura del file HTML con il browser predefinito: {}", e.getMessage());
-        }
+            logger.info("PDF generato: {} bytes", pdfFile.length());
+            return pdfFile;
 
-        if (chromePath != null && new File(chromePath).exists()) {
-            try {
-                List<String> command = new ArrayList<>();
-                command.add(chromePath);
-                command.add(htmlFile.toURI().toString());
-
-                logger.info("Tentativo di apertura HTML con Chrome esplicito: {}", String.join(" ", command));
-
-                ProcessBuilder pb = new ProcessBuilder(command);
-                pb.redirectErrorStream(true);
-                Process process = pb.start();
-                logger.info("Comando di apertura Chrome avviato per: {}", htmlFile.getAbsolutePath());
-
-            } catch (IOException e) {
-                logger.error("Errore durante il tentativo di aprire l'HTML con Chrome esplicito: {}", e.getMessage());
-            }
-        } else {
-            logger.warn("Impossibile aprire l'HTML nel browser: Desktop API non disponibile e percorso Chrome non valido.");
+        } catch (Exception e) {
+            logger.error("Errore conversione Chrome", e);
+            throw e;
         }
     }
 
-    /**
-     * Genera il file HTML completo dall'email parsata.
-     * Include CSS ottimizzato per stampa, gestione responsive e
-     * il contenuto dell'email processato per la conversione PDF.
-     *
-     * @param message L'oggetto Message contenente i dati dell'email
-     * @return Il file HTML generato e pronto per la conversione
-     * @throws IOException Se si verificano errori durante la generazione
-     */
     private File generateCompleteHtml(Message message) throws IOException {
         StringBuilder html = new StringBuilder();
 
-        // Header HTML standard
+        // HTML con CSS ottimizzato per Chrome container
         html.append("<!DOCTYPE html>\n");
         html.append("<html>\n");
         html.append("<head>\n");
@@ -275,32 +130,24 @@
         html.append("    <style>\n");
         html.append("        @page {\n");
         html.append("            size: A4;\n");
-        html.append("            margin: 0; /* Imposta i margini della pagina di stampa a 0 per eliminare spazi vuoti */\n");
+        html.append("            margin: 15mm;\n"); // Margini per leggibilità
         html.append("        }\n");
         html.append("        \n");
         html.append("        html, body {\n");
         html.append("            margin: 0;\n");
         html.append("            padding: 0;\n");
-        html.append("            height: 100%;\n"); // Assicura che html e body coprano l'intera altezza
-        html.append("            width: 100%;\n");
+        html.append("            font-family: Arial, Helvetica, sans-serif;\n");
+        html.append("            font-size: 12px;\n");
+        html.append("            line-height: 1.5;\n");
+        html.append("            color: #000000;\n");
+        html.append("            background: #ffffff;\n");
         html.append("        }\n");
         html.append("        \n");
-        html.append("        * {\n");
-        html.append("            box-sizing: border-box;\n");
-        html.append("        }\n");
-        html.append("        \n");
-        html.append("        body {\n");
-        html.append("            font-family: 'Segoe UI', Arial, sans-serif;\n");
-        html.append("            font-size: 11px;\n");
-        html.append("            line-height: 1.4;\n");
-        html.append("            color: #333;\n");
-        html.append("            background: white;\n");
-        html.append("        }\n");
-
         html.append("        .email-content {\n");
         html.append("            max-width: 100%;\n");
         html.append("            word-wrap: break-word;\n");
         html.append("            overflow-wrap: break-word;\n");
+        html.append("            padding: 10px;\n");
         html.append("        }\n");
         html.append("        \n");
         html.append("        img {\n");
@@ -314,7 +161,6 @@
         html.append("            border-collapse: collapse;\n");
         html.append("            width: 100%;\n");
         html.append("            margin: 8px 0;\n");
-        html.append("            font-size: inherit;\n");
         html.append("        }\n");
         html.append("        \n");
         html.append("        td, th {\n");
@@ -322,31 +168,6 @@
         html.append("            vertical-align: top;\n");
         html.append("            border: 1px solid #ddd;\n");
         html.append("            word-wrap: break-word;\n");
-        html.append("        }\n");
-        html.append("        \n");
-        html.append("        .no-print {\n");
-        html.append("            display: none !important;\n");
-        html.append("        }\n");
-        html.append("        \n");
-        html.append("        table table {\n");
-        html.append("            border: none;\n");
-        html.append("        }\n");
-        html.append("        \n");
-        html.append("        table table td {\n");
-        html.append("            border: none;\n");
-        html.append("        }\n");
-        html.append("        \n");
-        // NUOVE REGOLE CSS per nascondere i footer/header di stampa di Chrome
-        html.append("        @media print {\n");
-        html.append("            /* Nasconde gli header/footer testuali di Chrome */\n");
-        html.append("            body::before, body::after {\n");
-        html.append("                content: none !important;\n");
-        html.append("                display: none !important;\n");
-        html.append("            }\n");
-        html.append("            /* Forza i margini della pagina a zero per evitare spazi bianchi indesiderati */\n");
-        html.append("            @page {\n");
-        html.append("                margin: 0 !important;\n");
-        html.append("            }\n");
         html.append("        }\n");
         html.append("    </style>\n");
         html.append("</head>\n");
@@ -363,79 +184,131 @@
             writer.write(html.toString());
         }
 
-        logger.info("HTML generato: {}", htmlFile.getAbsolutePath());
+        // DEBUG: Log contenuto HTML generato
+        logHtmlContent(htmlFile);
+
         return htmlFile;
     }
 
-    /**
-     * Aggiunge gli header dell'email (Da, A, Oggetto, Data) all'HTML.
-     * Metodo helper per formattare le informazioni di intestazione dell'email.
-     *
-     * @param html Il StringBuilder dove aggiungere l'HTML degli header
-     * @param message L'oggetto Message contenente i dati dell'email
-     */
-    private void appendEmailHeaders(StringBuilder html, Message message) {
-        appendHeaderField(html, "Da:", getFieldValue(message.getFrom()));
-        appendHeaderField(html, "A:", getFieldValue(message.getTo()));
-        if (message.getCc() != null) {
-            appendHeaderField(html, "Cc:", getFieldValue(message.getCc()));
+    private void logHtmlContent(File htmlFile) {
+        try {
+            byte[] htmlBytes = Files.readAllBytes(htmlFile.toPath());
+            String htmlContent = new String(htmlBytes, StandardCharsets.UTF_8);
+
+            logger.info("=== DEBUG HTML GENERATO ===");
+            logger.info("HTML length: {}", htmlContent.length());
+            logger.info("Contiene 'Ciao'? {}", htmlContent.contains("Ciao"));
+            logger.info("Contiene 'Debora'? {}", htmlContent.contains("Debora"));
+            logger.info("Contiene 'Benetton'? {}", htmlContent.contains("Benetton"));
+
+            // Log preview (primi 1000 caratteri)
+            String preview = htmlContent.length() > 1000 ?
+                    htmlContent.substring(0, 1000) + "..." : htmlContent;
+            logger.info("HTML preview:\n{}", preview);
+
+        } catch (Exception e) {
+            logger.error("Errore lettura HTML per debug: {}", e.getMessage());
         }
-        appendHeaderField(html, "Oggetto:", message.getSubject());
-        appendHeaderField(html, "Data:", getFieldValue(message.getDate()));
     }
 
     /**
-     * Aggiunge un singolo campo di header formattato all'HTML.
-     *
-     * @param html Il StringBuilder dove aggiungere l'HTML
-     * @param label L'etichetta del campo (es. "Da:", "A:")
-     * @param value Il valore del campo
-     */
-    private void appendHeaderField(StringBuilder html, String label, String value) {
-        html.append("<div class=\"header-field\">")
-                .append("<span class=\"header-label\">").append(escapeHtml(label)).append("</span>")
-                .append("<span>").append(escapeHtml(value != null ? value : "")).append("</span>")
-                .append("</div>");
-    }
-
-    /**
-     * Processa ricorsivamente il contenuto dell'email e lo converte in HTML.
-     * Gestisce sia parti testuali (HTML/plain text) che multipart,
-     * processando le immagini embedded e i riferimenti CID.
-     *
-     * @param html Il StringBuilder dove aggiungere l'HTML del contenuto
-     * @param body Il Body dell'email da processare
-     * @throws IOException Se si verificano errori durante la lettura del contenuto
+     * Include sia HTML che text/plain
      */
     private void appendEmailContent(StringBuilder html, Body body) throws IOException {
+        logger.info("=== DEBUG EMAIL CONTENT ===");
+
         if (body instanceof TextBody) {
             TextBody textBody = (TextBody) body;
             String mimeType = getContentType(textBody);
             String content = readTextContent(textBody);
 
-            if (mimeType.contains("text/html")) {
-                String processedHtml = processCidReferences(content);
-                html.append(processedHtml);
-            } else if (mimeType.contains("text/plain")) {
-                // Non generiamo alcun HTML per il contenuto text/plain
-                // se non desiderato (come da tua precedente indicazione).
+            logger.info("TextBody trovato - MIME: {}", mimeType);
+            logger.info("Content length: {}", content != null ? content.length() : "NULL");
+
+            if (content != null && !content.trim().isEmpty()) {
+                if (mimeType.contains("text/html")) {
+                    String processedHtml = processCidReferences(content);
+                    html.append(processedHtml);
+                    logger.info("Aggiunto contenuto HTML");
+                } else if (mimeType.contains("text/plain")) {
+                    // INCLUDE IL TESTO SEMPLICE
+                    html.append("<div style=\"white-space: pre-wrap; font-family: inherit;\">");
+                    html.append(escapeHtml(content));
+                    html.append("</div>");
+                    logger.info("Aggiunto contenuto TEXT/PLAIN");
+                } else {
+                    // Fallback per altri tipi
+                    html.append("<div style=\"white-space: pre-wrap;\">");
+                    html.append(escapeHtml(content));
+                    html.append("</div>");
+                    logger.info("Aggiunto contenuto generico ({})", mimeType);
+                }
             }
         } else if (body instanceof Multipart) {
             Multipart multipart = (Multipart) body;
+            logger.info("Multipart con {} parti", multipart.getBodyParts().size());
+
+            boolean foundText = false;
+
+            // Prima cerca HTML
             for (Entity part : multipart.getBodyParts()) {
-                appendEmailContent(html, part.getBody());
+                if (part.getBody() instanceof TextBody) {
+                    TextBody textBody = (TextBody) part.getBody();
+                    String mimeType = getContentType(textBody);
+
+                    if (mimeType.contains("text/html")) {
+                        String content = readTextContent(textBody);
+                        if (content != null && !content.trim().isEmpty()) {
+                            String processedHtml = processCidReferences(content);
+                            html.append(processedHtml);
+                            foundText = true;
+                            logger.info("Usato HTML body da multipart");
+                            break;
+                        }
+                    }
+                }
+            }
+
+            // Se non trova HTML, usa text/plain
+            if (!foundText) {
+                for (Entity part : multipart.getBodyParts()) {
+                    if (part.getBody() instanceof TextBody) {
+                        TextBody textBody = (TextBody) part.getBody();
+                        String mimeType = getContentType(textBody);
+
+                        if (mimeType.contains("text/plain")) {
+                            String content = readTextContent(textBody);
+                            if (content != null && !content.trim().isEmpty()) {
+                                html.append("<div style=\"white-space: pre-wrap; font-family: inherit;\">");
+                                html.append(escapeHtml(content));
+                                html.append("</div>");
+                                foundText = true;
+                                logger.info("Usato text/plain body da multipart");
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            // Recursione per parti annidate
+            for (Entity part : multipart.getBodyParts()) {
+                if (part.getBody() instanceof Multipart) {
+                    appendEmailContent(html, part.getBody());
+                }
             }
-        }
-    }
+
+            if (!foundText) {
+                html.append("<div style=\"color: #666; font-style: italic;\">");
+                html.append("Nessun contenuto testuale trovato nell'email.");
+                html.append("</div>");
+                logger.warn("Nessun contenuto testuale trovato");
+            }
+        }
 
-    /**
-     * Estrae ricorsivamente le immagini embedded dall'email.
-     * Cerca parti con MIME type image/* e Content-ID, salvandole come file temporanei
-     * per il riferimento nell'HTML generato.
-     *
-     * @param body Il Body dell'email da analizzare
-     * @throws IOException Se si verificano errori durante l'estrazione
-     */
+        logger.info("=== FINE DEBUG EMAIL CONTENT ===");
+    }
+    // Continuazione da extractEmbeddedImages
     private void extractEmbeddedImages(Body body) throws IOException {
         if (body instanceof TextBody) {
             TextBody textBody = (TextBody) body;
@@ -455,15 +328,6 @@
         }
     }
 
-    /**
-     * Salva un'immagine embedded decodificando il contenuto Base64.
-     * Crea un file temporaneo e mappa il Content-ID per i riferimenti HTML.
-     *
-     * @param textBody Il TextBody contenente i dati dell'immagine
-     * @param contentId Il Content-ID dell'immagine per i riferimenti CID
-     * @param mimeType Il tipo MIME dell'immagine
-     * @throws IOException Se si verificano errori durante il salvataggio
-     */
     private void saveEmbeddedImage(TextBody textBody, String contentId, String mimeType) throws IOException {
         String content = readTextContent(textBody);
 
@@ -485,13 +349,6 @@
         }
     }
 
-    /**
-     * Processa i riferimenti CID nell'HTML sostituendoli con percorsi file locali.
-     * Converte i riferimenti "cid:contentId" in percorsi "file:///" per Chrome.
-     *
-     * @param htmlContent Il contenuto HTML da processare
-     * @return L'HTML con i riferimenti CID sostituiti
-     */
     private String processCidReferences(String htmlContent) {
         String processed = htmlContent;
 
@@ -507,12 +364,6 @@
         return processed;
     }
 
-    /**
-     * Estrae il Content-Type dal TextBody analizzando gli header della parte.
-     *
-     * @param textBody Il TextBody da analizzare
-     * @return Il tipo MIME, o "text/plain" come default
-     */
     private String getContentType(TextBody textBody) {
         Entity parent = textBody.getParent();
         if (parent != null && parent.getHeader() != null) {
@@ -522,12 +373,6 @@
         return "text/plain";
     }
 
-    /**
-     * Estrae il Content-ID dal TextBody analizzando gli header della parte.
-     *
-     * @param textBody Il TextBody da analizzare
-     * @return Il Content-ID, o null se non presente
-     */
     private String getContentId(TextBody textBody) {
         Entity parent = textBody.getParent();
         if (parent != null && parent.getHeader() != null) {
@@ -537,36 +382,28 @@
         return null;
     }
 
-    /**
-     * Legge il contenuto testuale di un TextBody rilevando automaticamente l'encoding
-     * dall'header Content-Type. Supporta fallback intelligente per encoding non supportati.
-     *
-     * @param textBody Il TextBody da leggere
-     * @return Il contenuto testuale decodificato correttamente
-     * @throws IOException Se si verificano errori durante la lettura
-     */
     private String readTextContent(TextBody textBody) throws IOException {
         String charset = getCharset(textBody);
 
-        // Prima prova con il charset rilevato
+        // Prima prova con charset rilevato
         try (InputStreamReader reader = new InputStreamReader(textBody.getInputStream(), charset)) {
             return readFromReader(reader);
         } catch (UnsupportedEncodingException e) {
-            logger.warn("Charset non supportato: {}, tentativo fallback su UTF-8", charset);
+            logger.warn("Charset non supportato: {}, fallback su UTF-8", charset);
 
-            // Fallback 1: UTF-8
+            // Fallback UTF-8
             try (InputStreamReader reader = new InputStreamReader(textBody.getInputStream(), StandardCharsets.UTF_8)) {
                 return readFromReader(reader);
             } catch (Exception e2) {
-                logger.warn("Fallback UTF-8 fallito, tentativo con ISO-8859-1");
+                logger.warn("Fallback UTF-8 fallito, provo ISO-8859-1");
 
-                // Fallback 2: ISO-8859-1 (supporta tutti i byte 0-255)
+                // Fallback ISO-8859-1
                 try (InputStreamReader reader = new InputStreamReader(textBody.getInputStream(), StandardCharsets.ISO_8859_1)) {
                     return readFromReader(reader);
                 } catch (Exception e3) {
-                    logger.error("Tutti i tentativi di decodifica falliti, uso default system charset");
+                    logger.error("Tutti i tentativi di decodifica falliti, uso charset di sistema");
 
-                    // Fallback finale: charset di sistema
+                    // Fallback finale
                     try (InputStreamReader reader = new InputStreamReader(textBody.getInputStream())) {
                         return readFromReader(reader);
                     }
@@ -575,35 +412,21 @@
         }
     }
 
-    /**
-     * Rileva il charset dall'header Content-Type del TextBody.
-     *
-     * @param textBody Il TextBody da analizzare
-     * @return Il charset rilevato o "UTF-8" come default
-     */
     private String getCharset(TextBody textBody) {
         Entity parent = textBody.getParent();
         if (parent != null && parent.getHeader() != null) {
             ContentTypeField field = (ContentTypeField) parent.getHeader().getField("Content-Type");
             if (field != null && field.getCharset() != null) {
                 String charset = field.getCharset();
-                logger.debug("Charset rilevato dall'header: {}", charset);
+                logger.debug("Charset rilevato: {}", charset);
                 return charset;
             }
         }
 
-        // Default fallback
-        logger.debug("Nessun charset specificato, uso UTF-8 come default");
+        logger.debug("Nessun charset specificato, uso UTF-8");
         return "UTF-8";
     }
 
-    /**
-     * Utility method per leggere da un InputStreamReader.
-     *
-     * @param reader Il reader da cui leggere
-     * @return Il contenuto letto come stringa
-     * @throws IOException Se si verificano errori durante la lettura
-     */
     private String readFromReader(InputStreamReader reader) throws IOException {
         StringBuilder sb = new StringBuilder();
         char[] buffer = new char[4096];
@@ -614,45 +437,20 @@
         return sb.toString();
     }
 
-    /**
-     * Converte un tipo MIME in estensione file appropriata.
-     *
-     * @param mimeType Il tipo MIME da convertire
-     * @return L'estensione file corrispondente
-     */
     private String getImageExtension(String mimeType) {
+        if (mimeType == null) return "img";
         String lowerType = mimeType.toLowerCase();
-        if ("image/gif".equals(lowerType)) {
-            return "gif";
-        } else if ("image/jpeg".equals(lowerType)) {
-            return "jpg";
-        } else if ("image/png".equals(lowerType)) {
-            return "png";
-        } else if ("image/bmp".equals(lowerType)) {
-            return "bmp";
-        } else if ("image/webp".equals(lowerType)) {
-            return "webp";
-        } else {
-            return "img";
+
+        switch (lowerType) {
+            case "image/gif": return "gif";
+            case "image/jpeg": return "jpg";
+            case "image/png": return "png";
+            case "image/bmp": return "bmp";
+            case "image/webp": return "webp";
+            default: return "img";
         }
     }
 
-    /**
-     * Converte un oggetto field in stringa per la visualizzazione.
-     *
-     * @param field L'oggetto field da convertire
-     * @return La rappresentazione stringa del field, o stringa vuota se null
-     */
-    private String getFieldValue(Object field) {
-        return field != null ? field.toString() : "";
-    }
-
-    /**
-     * Effettua l'escape dei caratteri HTML speciali per evitare problemi di rendering.
-     *
-     * @param text Il testo da processare
-     * @return Il testo con i caratteri HTML escapati
-     */
     private String escapeHtml(String text) {
         if (text == null) return "";
         return text.replace("&", "&amp;")
@@ -662,24 +460,18 @@
                 .replace("'", "&#39;");
     }
 
-    @Deprecated
-    /**
-     * Pulisce i file temporanei e la directory di lavoro.
-     * Elimina tutti i file nella directory temporanea e poi la directory stessa.
-     * Viene chiamato nel blocco finally se DEBUG_KEEP_TEMP_FILES è false.
-     */
     private void cleanup() {
         if (tempDir != null && tempDir.exists()) {
             File[] files = tempDir.listFiles();
             if (files != null) {
                 for (File file : files) {
                     if (!file.delete()) {
-                        logger.warn("Impossibile eliminare il file temporaneo: {}", file.getAbsolutePath());
+                        logger.warn("Impossibile eliminare file temporaneo: {}", file.getAbsolutePath());
                     }
                 }
             }
             if (!tempDir.delete()) {
-                logger.warn("Impossibile eliminare la directory temporanea: {}", tempDir.getAbsolutePath());
+                logger.warn("Impossibile eliminare directory temporanea: {}", tempDir.getAbsolutePath());
             }
         }
         embeddedImages.clear();
Index: target/classes/converter.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Chrome/Chromium Configuration for Docker\n# Optimized for high performance in containerized environments\n\n# Chrome executable paths (Docker priority order)\nchrome.docker.paths=/usr/bin/google-chrome:/usr/bin/google-chrome-stable:/usr/bin/chromium-browser:/usr/bin/chromium\n\n# Chrome arguments optimized for performance in Docker\nchrome.args=--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --single-process --run-all-compositor-stages-before-draw --disable-features=VizDisplayCompositor --disable-background-timer-throttling --disable-renderer-backgrounding --memory-pressure-off --max_old_space_size=2048 --js-flags=--max-old-space-size=2048 --disable-web-security --allow-file-access-from-files --disable-extensions --disable-plugins --disable-features=TranslateUI --disable-default-apps --disable-component-extensions-with-background-pages --disable-backgrounding-occluded-windows --virtual-time-budget=15000 --timeout=30000\n\n# Chrome process timeout in seconds\nchrome.timeout.seconds=45\n\n# Enable automatic cleanup of temporary files\nchrome.temp.cleanup=true\n\n# Chrome memory limits\nchrome.memory.max_old_space_size=2048\nchrome.memory.js_flags=--max-old-space-size=2048\n\n# PDF generation settings\nchrome.pdf.no_header=true\nchrome.pdf.no_footer=true\nchrome.pdf.format=A4\nchrome.pdf.margin=0\n\n# Performance tuning\nchrome.virtual_time_budget=15000\nchrome.compositor_stages=true\nchrome.disable_viz_compositor=true\n\n# Debug settings (set to false in production)\nchrome.debug.keep_temp_files=false\nchrome.debug.open_html_in_browser=false\nchrome.debug.verbose_logging=true
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/target/classes/converter.properties b/target/classes/converter.properties
--- a/target/classes/converter.properties	(revision c03fcda81ec80ee23b4f0e9aa9b8f8e2a00cc447)
+++ b/target/classes/converter.properties	(date 1751446066683)
@@ -1,34 +1,18 @@
-# Chrome/Chromium Configuration for Docker
-# Optimized for high performance in containerized environments
+# converter.properties - Configurazione Chrome per Docker Container
 
-# Chrome executable paths (Docker priority order)
-chrome.docker.paths=/usr/bin/google-chrome:/usr/bin/google-chrome-stable:/usr/bin/chromium-browser:/usr/bin/chromium
+# Chrome paths per il container Docker
+chrome.docker.paths=/usr/bin/chrome:/opt/chrome/chrome:/usr/bin/google-chrome:/usr/bin/google-chrome-stable:/usr/bin/chromium-browser
 
-# Chrome arguments optimized for performance in Docker
-chrome.args=--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --single-process --run-all-compositor-stages-before-draw --disable-features=VizDisplayCompositor --disable-background-timer-throttling --disable-renderer-backgrounding --memory-pressure-off --max_old_space_size=2048 --js-flags=--max-old-space-size=2048 --disable-web-security --allow-file-access-from-files --disable-extensions --disable-plugins --disable-features=TranslateUI --disable-default-apps --disable-component-extensions-with-background-pages --disable-backgrounding-occluded-windows --virtual-time-budget=15000 --timeout=30000
+# Argomenti Chrome ottimizzati per container Docker
+chrome.args=--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --disable-web-security --allow-file-access-from-files --disable-features=VizDisplayCompositor --disable-background-timer-throttling --disable-backgrounding-occluded-windows --disable-renderer-backgrounding --disable-features=TranslateUI --run-all-compositor-stages-before-draw --disable-ipc-flooding-protection --virtual-time-budget=30000
 
-# Chrome process timeout in seconds
-chrome.timeout.seconds=45
+# Timeout per operazioni Chrome
+chrome.timeout.seconds=60
 
-# Enable automatic cleanup of temporary files
+# Cleanup automatico file temporanei
 chrome.temp.cleanup=true
 
-# Chrome memory limits
-chrome.memory.max_old_space_size=2048
-chrome.memory.js_flags=--max-old-space-size=2048
-
-# PDF generation settings
-chrome.pdf.no_header=true
-chrome.pdf.no_footer=true
-chrome.pdf.format=A4
-chrome.pdf.margin=0
-
-# Performance tuning
-chrome.virtual_time_budget=15000
-chrome.compositor_stages=true
-chrome.disable_viz_compositor=true
-
-# Debug settings (set to false in production)
-chrome.debug.keep_temp_files=false
-chrome.debug.open_html_in_browser=false
-chrome.debug.verbose_logging=true
\ No newline at end of file
+# Percorsi di fallback per diversi OS (non usati in Docker ma mantenuti per compatibilità)
+chrome.fallback.linux=/usr/bin/google-chrome:/usr/bin/chromium-browser
+chrome.fallback.windows=C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe
+chrome.fallback.mac=/Applications/Google Chrome.app/Contents/MacOS/Google Chrome
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"ae06c050-a8b9-4ebf-af63-83415233d5c8\" name=\"Changes\" comment=\"immagini funzionano\">\n      <change afterPath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_43_[Changes]/file-type-converter-1.0-SNAPSHOT.jar.original\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_43_[Changes]/shelved.patch\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_43_[Changes]1/file-type-converter-1.0-SNAPSHOT.jar.original\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_43_[Changes]1/shelved.patch\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_45_[Changes]/shelved.patch\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25__17_43__Changes_.xml\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25__17_43__Changes_1.xml\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25__17_45__Changes_.xml\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/input/I_ Ordine confermato. Questo si dice avere buon gusto!-2.eml\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/log4j/log_current.txt\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/auth/AuthException.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/auth/AuthResponse.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/auth/AuthService.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/auth/LoginRequest.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/auth/RegisterRequest.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/auth/User.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/auth/UserDTO.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/auth/entity/UserEntity.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/auth/repository/UserRepository.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/ChromeManager.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/EMLtoPDFconverter.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/MSGtoPDFconverter.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/output/success/I_ Ordine confermato. Questo si dice avere buon gusto!-2.pdf\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/target/classes/application.properties\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/target/classes/converter.properties\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/target/classes/log4j2.xml\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/target/classes/serverConfig.json\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/target/classes/themplate.doc\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/target/file-type-converter-1.0-SNAPSHOT.jar.original\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/target/maven-archiver/pom.properties\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/target/maven-status/maven-compiler-plugin/compile/default-compile/createdFiles.lst\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/target/maven-status/maven-compiler-plugin/compile/default-compile/inputFiles.lst\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"CSS File\" />\n        <option value=\"Exception\" />\n        <option value=\"FxmlFile\" />\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"docker\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitHubPullRequestSearchHistory\">{\n  &quot;lastFilter&quot;: {\n    &quot;state&quot;: &quot;OPEN&quot;,\n    &quot;assignee&quot;: &quot;Simone-Rossi-GB&quot;\n  }\n}</component>\n  <component name=\"GithubPullRequestsUISettings\">{\n  &quot;selectedUrlAndAccountId&quot;: {\n    &quot;url&quot;: &quot;https://github.com/Simone-Rossi-GB/convertitoreFile.git&quot;,\n    &quot;accountId&quot;: &quot;16ca8634-d246-4f42-88af-20327ac34cc3&quot;\n  }\n}</component>\n  <component name=\"KubernetesApiPersistence\">{}</component>\n  <component name=\"KubernetesApiProvider\">{\n  &quot;isMigrated&quot;: true\n}</component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 5\n}</component>\n  <component name=\"ProjectId\" id=\"2zE2BImB4H1kkEv7549tZZb85XC\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;Application.MainApp.executor&quot;: &quot;Run&quot;,\n    &quot;RequestMappingsPanelOrder0&quot;: &quot;0&quot;,\n    &quot;RequestMappingsPanelOrder1&quot;: &quot;1&quot;,\n    &quot;RequestMappingsPanelWidth0&quot;: &quot;75&quot;,\n    &quot;RequestMappingsPanelWidth1&quot;: &quot;75&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;Spring Boot.WebServiceApplication (1).executor&quot;: &quot;Run&quot;,\n    &quot;Spring Boot.WebServiceApplication.executor&quot;: &quot;Run&quot;,\n    &quot;git-widget-placeholder&quot;: &quot;docker+auth&quot;,\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\n    &quot;last_opened_file_path&quot;: &quot;/Users/simo/Documents/GitHub/convertitoreFileDocker/src/main/java/webService/client/auth&quot;,\n    &quot;list.type.of.created.stylesheet&quot;: &quot;CSS&quot;,\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\n    &quot;project.structure.proportion&quot;: &quot;0.0&quot;,\n    &quot;project.structure.side.proportion&quot;: &quot;0.0&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;reference.settings.project.maven.repository.indices&quot;,\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\n  }\n}</component>\n  <component name=\"RecentsManager\">\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/src/main/java/webService/client/auth\" />\n      <recent name=\"$PROJECT_DIR$/src/main/java/webService/server\" />\n    </key>\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/src/main/java/webService/server/converters\" />\n      <recent name=\"$PROJECT_DIR$/src/main/resources\" />\n      <recent name=\"$PROJECT_DIR$/src/main/java/webService/server\" />\n      <recent name=\"$PROJECT_DIR$\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"Spring Boot.WebServiceApplication (1)\">\n    <configuration name=\"MainApp\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"webService.client.gui.MainApp\" />\n      <module name=\"file-type-converter\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"webService.client.gui.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JetRunConfigurationType\">\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"KotlinStandaloneScriptRunConfigurationType\">\n      <option name=\"filePath\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"WebServiceApplication (1)\" type=\"SpringBootApplicationConfigurationType\" factoryName=\"Spring Boot\" nameIsGenerated=\"true\">\n      <module name=\"file-type-converter\" />\n      <option name=\"SPRING_BOOT_MAIN_CLASS\" value=\"webService.server.WebServiceApplication\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"WebServiceApplication\" type=\"SpringBootApplicationConfigurationType\" factoryName=\"Spring Boot\" nameIsGenerated=\"true\">\n      <module name=\"file-type-converter\" />\n      <option name=\"SPRING_BOOT_MAIN_CLASS\" value=\"WebService.WebServiceApplication\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Application.MainApp\" />\n        <item itemvalue=\"Application.MainApp\" />\n        <item itemvalue=\"Application.MainApp\" />\n        <item itemvalue=\"Application.MainApp\" />\n        <item itemvalue=\"Application.MainApp\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SharedIndexes\">\n    <attachedChunks>\n      <set>\n        <option value=\"bundled-jdk-9823dce3aa75-28b599e66164-intellij.indexing.shared.core-IU-242.23339.11\" />\n        <option value=\"bundled-js-predefined-d6986cc7102b-5c90d61e3bab-JavaScript-IU-242.23339.11\" />\n      </set>\n    </attachedChunks>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"ae06c050-a8b9-4ebf-af63-83415233d5c8\" name=\"Changes\" comment=\"\" />\n      <created>1751281774578</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1751281774578</updated>\n      <workItem from=\"1751281775752\" duration=\"5847000\" />\n      <workItem from=\"1751291089336\" duration=\"7644000\" />\n      <workItem from=\"1751298834373\" duration=\"1596000\" />\n      <workItem from=\"1751353270309\" duration=\"8351000\" />\n      <workItem from=\"1751361747632\" duration=\"8025000\" />\n      <workItem from=\"1751373943491\" duration=\"8342000\" />\n      <workItem from=\"1751382501361\" duration=\"1577000\" />\n      <workItem from=\"1751384089795\" duration=\"1609000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"er\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751290750927</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751290750927</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"er\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751290820946</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751290820946</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"er\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751291386154</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751291386154</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"er\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751291978046</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751291978046</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"er\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751294436583</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751294436583</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"er\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751296940574</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751296940574</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"er\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751296976174</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751296976174</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751297675960</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751297675960</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751353886554</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751353886555</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751360326840</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751360326840</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751364898441</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751364898442</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751371509605</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751371509605</updated>\n    </task>\n    <task id=\"LOCAL-00013\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751373530607</created>\n      <option name=\"number\" value=\"00013\" />\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751373530607</updated>\n    </task>\n    <task id=\"LOCAL-00014\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751374129957</created>\n      <option name=\"number\" value=\"00014\" />\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751374129957</updated>\n    </task>\n    <task id=\"LOCAL-00015\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751374683259</created>\n      <option name=\"number\" value=\"00015\" />\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751374683259</updated>\n    </task>\n    <task id=\"LOCAL-00016\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751378516243</created>\n      <option name=\"number\" value=\"00016\" />\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751378516243</updated>\n    </task>\n    <task id=\"LOCAL-00017\" summary=\"immagini funzionano\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1751385449759</created>\n      <option name=\"number\" value=\"00017\" />\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1751385449759</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"18\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"er\" />\n    <MESSAGE value=\"immagini funzionano\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"immagini funzionano\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision c03fcda81ec80ee23b4f0e9aa9b8f8e2a00cc447)
+++ b/.idea/workspace.xml	(date 1751446614234)
@@ -5,39 +5,15 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="ae06c050-a8b9-4ebf-af63-83415233d5c8" name="Changes" comment="immagini funzionano">
-      <change afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_43_[Changes]/file-type-converter-1.0-SNAPSHOT.jar.original" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_43_[Changes]/shelved.patch" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_43_[Changes]1/file-type-converter-1.0-SNAPSHOT.jar.original" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_43_[Changes]1/shelved.patch" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25,_17_45_[Changes]/shelved.patch" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25__17_43__Changes_.xml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25__17_43__Changes_1.xml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_30_06_25__17_45__Changes_.xml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/input/I_ Ordine confermato. Questo si dice avere buon gusto!-2.eml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/log4j/log_current.txt" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/auth/AuthException.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/auth/AuthResponse.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/auth/AuthService.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/auth/LoginRequest.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/auth/RegisterRequest.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/auth/User.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/auth/UserDTO.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/auth/entity/UserEntity.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/auth/repository/UserRepository.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/ChromeManager.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/EMLtoPDFconverter.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/MSGtoPDFconverter.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/output/success/I_ Ordine confermato. Questo si dice avere buon gusto!-2.pdf" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/target/classes/application.properties" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/target/classes/converter.properties" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/target/classes/log4j2.xml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/target/classes/serverConfig.json" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/target/classes/themplate.doc" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/target/file-type-converter-1.0-SNAPSHOT.jar.original" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/target/maven-archiver/pom.properties" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/target/maven-status/maven-compiler-plugin/compile/default-compile/createdFiles.lst" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/target/maven-status/maven-compiler-plugin/compile/default-compile/inputFiles.lst" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Dockerfile" beforeDir="false" afterPath="$PROJECT_DIR$/Dockerfile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/docker-compose.yml" beforeDir="false" afterPath="$PROJECT_DIR$/docker-compose.yml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/ChromeManager.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/ChromeManager.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/EMLtoPDFconverter.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/EMLtoPDFconverter.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/MSGtoPDFconverter.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters/MSGtoPDFconverter.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/resources/converter.properties" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/resources/converter.properties" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/converter.properties" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/converter.properties" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/file-type-converter-1.0-SNAPSHOT.jar.original" beforeDir="false" afterPath="$PROJECT_DIR$/target/file-type-converter-1.0-SNAPSHOT.jar.original" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -118,10 +94,11 @@
       <recent name="$PROJECT_DIR$/src/main/java/webService/server" />
     </key>
     <key name="MoveFile.RECENT_KEYS">
+      <recent name="$PROJECT_DIR$/src/main/java/webService/server/converters/mailConverters" />
+      <recent name="$PROJECT_DIR$" />
       <recent name="$PROJECT_DIR$/src/main/java/webService/server/converters" />
       <recent name="$PROJECT_DIR$/src/main/resources" />
       <recent name="$PROJECT_DIR$/src/main/java/webService/server" />
-      <recent name="$PROJECT_DIR$" />
     </key>
   </component>
   <component name="RunManager" selected="Spring Boot.WebServiceApplication (1)">
@@ -196,7 +173,7 @@
       <workItem from="1751361747632" duration="8025000" />
       <workItem from="1751373943491" duration="8342000" />
       <workItem from="1751382501361" duration="1577000" />
-      <workItem from="1751384089795" duration="1609000" />
+      <workItem from="1751384089795" duration="11546000" />
     </task>
     <task id="LOCAL-00001" summary="er">
       <option name="closed" value="true" />
@@ -334,7 +311,15 @@
       <option name="project" value="LOCAL" />
       <updated>1751385449759</updated>
     </task>
-    <option name="localTasksCounter" value="18" />
+    <task id="LOCAL-00018" summary="immagini funzionano">
+      <option name="closed" value="true" />
+      <created>1751400614475</created>
+      <option name="number" value="00018" />
+      <option name="presentableId" value="LOCAL-00018" />
+      <option name="project" value="LOCAL" />
+      <updated>1751400614475</updated>
+    </task>
+    <option name="localTasksCounter" value="19" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
